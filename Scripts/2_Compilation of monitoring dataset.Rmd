---
title: "FSCI 2024 - Compilation of monitoring dataset"
author: "Kate Schneider"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: html_document
---

### *Overall Objectives*

This script does the following actions cleans and merges all of the data for the Food Systems Countdown Initiative indicators to create the updated monitoring dataset for 2024 analysis.

# *Setup and Housekeeping*
```{r setup, warning = FALSE, messages = FALSE, results = "hide", echo = TRUE}
### Setup required to knit this script into a markdown document
    
### Load packages
    # R studio should prompt the installation of any packages not loaded on the instance where this script has been opened
    
    # Data management and multipurpose packages
    library(countrycode)
    library(knitr)
    library(readxl)
    library(stringr)
    library(tidyverse)
    library(readxl)
    library(terra)

### File management
  
    # Set the root folder to the project root so that all file paths are relative to the main project folder
    knitr::opts_knit$set('./')
    
    # Set relative directory paths
      data_in <- here::here("Input data")
      data_out <- here::here("Output data")
      figtab_out <- here::here("Figures & Tables")

### Set preferred options
    
    # Set the treatment of numbers to numerical (avoids scientific notation from showing in results)
    options(scipen = 999)
  
    # Set echo = FALSE for all code chunks will prevent the code from printing in the output file as the default setting (set to TRUE where relevant)
    knitr::opts_chunk$set(echo = FALSE)

### Functions
    
    # Create a "not in" operator
    `%notin%` <- Negate(`%in%`) 
    
### Organization
    col_order <- c("country", "M49_code", "ISO3", "indicator", 
           "year", "value", "unit")
    row_order <- c("country", "year", "variable_order")
    
```


# *Build updated monitoring dataset*

$~$

#### Import Data
Data are imported by data source. First we import all sources that have an API in script 1 and load the archived dataset here. Next we import data from other direct downloads. Last, we import data that has to be manually downloaded first. Manually downloaded data are contained in the R project sub-folder "Input Data".
```{r, warning = FALSE, messages = FALSE, cache = TRUE}

### Load the data pulled in API pulls in Script 1

load(file.path(data_in, "archived_data_pulls.RData"))
load(file.path(data_in, "mufpp_2023_archive.RData"))

### Now clean the data pulled in by API

###############################################
#   FAOSTAT                                   #
###############################################

    # Data cleaning
      names(fao_data)
      unique(fao_data$Item)
      # Create a list of elements to exclude:
      toexclude = c("Prevalence of moderate or severe food insecurity in the female adult population (percent) (3-year average)", 
                    "Prevalence of moderate or severe food insecurity in the female adult population (percent) (annual value)",
                    "Prevalence of moderate or severe food insecurity in the male adult population (percent) (3-year average)",
                    "Prevalence of moderate or severe food insecurity in the male adult population (percent) (annual value)",
                    "Prevalence of moderate or severe food insecurity in the rural adult population (percent) (annual value)",
                    "Prevalence of moderate or severe food insecurity in the total population (percent) (annual value)",
                    "Prevalence of moderate or severe food insecurity in the town and semi-dense area adult population (percent) (annual value)",
                    "Prevalence of moderate or severe food insecurity in the urban adult population (percent) (annual value)",
                    "Prevalence of undernourishment (percent) (annual value)")
        
    # Assign 3-year average to midpoint year for food insecurity and prevalence of undernourishment
      # The annual data are only made available for aggregate country groups, only 3-year averages are available at the country level. To align with our country-year unit of analysis we have to assign the 3-year average to a single year. We select the midpoint year. 
      fao_data <- fao_data %>%
      # Keep only the total population and 3-year average value for FIES & 3-year average value for PoU
        filter(Item %notin% toexclude) 
      
      # Checks:
        unique(fao_data$Year)
        unique(fao_data$Item)
        unique(fao_data$Element)
        
      # Deal with multi-year averages by assigning observation to the midpoint year:
        fao_data <- fao_data %>%
          mutate(Year = case_when(Year == "2000-2002" ~ "2001",
                                  Year == "2001-2003" ~ "2002",
                                  Year == "2002-2004" ~ "2003",
                                  Year == "2003-2005" ~ "2004",
                                  Year == "2004-2006" ~ "2005",
                                  Year == "2005-2007" ~ "2006",
                                  Year == "2006-2008" ~ "2007",
                                  Year == "2007-2009" ~ "2008",
                                  Year == "2008-2010" ~ "2009",
                                  Year == "2009-2011" ~ "2010",
                                  Year == "2010-2012" ~ "2011",
                                  Year == "2011-2013" ~ "2012",
                                  Year == "2012-2014" ~ "2013",
                                  Year == "2013-2015" ~ "2014",
                                  Year == "2014-2016" ~ "2015",
                                  Year == "2015-2017" ~ "2016",
                                  Year == "2016-2018" ~ "2017",
                                  Year == "2017-2019" ~ "2018",
                                  Year == "2018-2020" ~ "2019",
                                  Year == "2019-2021" ~ "2020",
                                  Year == "2020-2022" ~ "2021",
                                  TRUE ~ Year),
                 Element = case_when(Item == "Prevalence of moderate or severe food insecurity in the total population (percent) (3-year average)" ~ "% Population experiencing moderate or severe food insecurity (SDG 2.1.2)",
                                  Item == "Prevalence of undernourishment (percent) (3-year average)" ~ "PoU: Prevalence of Undernourishment (SDG 2.1.1)",
                                  TRUE ~ Element),
                 Year = as.numeric(Year))

    fao_data <- fao_data %>%
      rename(year = Year, country = Area, unit = Unit, value = Value, M49_code = "Area Code (M49)") %>%
      select(-c("Domain Code","Domain","Element Code","Item Code","Year Code")) %>%
      filter(year >= 2000 & year <= 2022) %>%
      mutate(Element = case_when(Element == "Value" ~ Item,
                                 TRUE ~ Element),
             Item = case_when(Element == Item ~ "",
                              TRUE ~ Item),
             M49_code = as.numeric(M49_code)) %>%
      rename(indicator = Element,
             item = Item)

    # Now combine the item into the indicator name
      fao_data <- fao_data %>%
        mutate(indicator = as.factor(indicator),
               item = as.factor(item)) %>%
        droplevels()
  
      fao_data <- fao_data %>%
        mutate(indicator = case_when(indicator == "Share of GDP from agriculture" ~ "Share of agriculture in GDP",
                                     indicator == "Emissions intensity" & item == "Cereals excluding rice" ~ "Emissions intensity, cereals (excl. rice)",
                                     indicator == "Emissions intensity" & item == "Raw milk of cattle" ~ "Emissions intensity, milk",
                                     indicator == "Emissions intensity" & item == "Rice" ~ "Emissions intensity, rice",
                                     indicator == "Emissions intensity" & item == "Meat of cattle with the bone, fresh or chilled" ~ "Emissions intensity, beef",
                                     indicator == "Yield" & item == "Cereals, primary" ~ "Yield, cereals",
                                     indicator == "Yield/Carcass Weight" & item == "Meat of cattle with the bone, fresh or chilled" ~ "Yield, beef",
                                     indicator == "Yield" & item == "Fruit Primary" ~ "Yield, fruit",
                                     indicator == "Yield" & item == "Raw milk of cattle" ~ "Yield, milk",
                                     indicator == "Yield" & item == "Vegetables Primary" ~ "Yield, vegetables",
                                     indicator == "Food supply quantity (kg/capita/yr)" & item == "Fruits - Excluding Wine" ~ "Availability of fruits and vegetables per capita, fruits",
                                     indicator == "Food supply quantity (kg/capita/yr)" & item == "Vegetables" ~ "Availability of fruits and vegetables per capita, vegetables",
                                     indicator == "Emissions (CO2eq) (AR5)" ~ "Total food system emissions (CO2eq) (AR5)",
                                     indicator == "Area" & item == "Cropland" ~ "Cropland area",
                                     indicator == "Area" & item == "Agricultural land" ~ "Agricultural land area",
                                     indicator == "Area" & item == "Country area" ~ "Country land area",
                                     indicator == "Use per area of cropland" & item == "Pesticides (total)" ~ "Pesticide use per area of cropland",
                                     indicator == "Production" & item == "Meat of cattle with the bone, fresh or chilled" ~ "Total production (denominator of emissions intensity), beef",
                                     indicator == "Production" & item == "Raw milk of cattle" ~ "Total production (denominator of emissions intensity), milk",
                                     indicator == "Production" & item == "Cereals excluding rice" ~ "Total production (denominator of emissions intensity), cereals (excl. rice)",
                                     indicator == "Production" & item == "Rice" ~ "Total production (denominator of emissions intensity), rice",
                                     indicator == "Producing Animals/Slaughtered" & item == "Beef and Buffalo Meat, primary" ~ "Slaughtered animals (denominator of yield values), beef",
                                     indicator == "Milk Animals" & item == "Milk, Total" ~ "Producing animals (denominator of yield values), milk",
                                     indicator == "Area harvested" & item == "Cereals, primary" ~ "Area harvested (denominator of yield values), cereals",
                                     indicator == "Area harvested" & item == "Fruit Primary" ~ "Area harvested (denominator of yield values), fruit",
                                     indicator == "Area harvested" & item == "Vegetables Primary" ~ "Area harvested (denominator of yield values), vegetables",
                                     TRUE ~ indicator))
    
    # Transform yields into tonnes/ha (from 100g/ha) and kg/animal (from 100g/animal) so that we have the same units of measure across items for yield indicator
      fao_data <- fao_data %>%
        mutate(value = as.numeric(value),
               value = case_when(str_detect(indicator, pattern = "^Yield") & item == "Meat of cattle with the bone, fresh or chilled" ~ value/10,
                                 str_detect(indicator, pattern = "^Yield") & item == "Raw milk of cattle" ~ value/10,
                                 str_detect(indicator, pattern = "^Yield") & item == "Cereals, primary" ~ value/10000,
                                 str_detect(indicator, pattern = "^Yield") & item == "Fruit Primary" ~ value/10000,
                                 str_detect(indicator, pattern = "^Yield") & item == "Vegetables Primary" ~ value/10000,
                                 TRUE ~ value),
               unit = case_when(str_detect(indicator, pattern = "^Yield") & item == "Meat of cattle with the bone, fresh or chilled" ~ "kg/animal",
                                 str_detect(indicator, pattern = "^Yield") & item == "Raw milk of cattle" ~ "kg/animal",
                                 str_detect(indicator, pattern = "^Yield") & item == "Cereals, primary" ~ "tonnes/ha",
                                 str_detect(indicator, pattern = "^Yield") & item == "Fruit Primary" ~ "tonnes/ha",
                                 str_detect(indicator, pattern = "^Yield") & item == "Vegetables Primary" ~ "tonnes/ha",
                                TRUE ~ unit))
        
    # Transform fruit and vegetable availability to grams/day (from kg/capita/year)
      fao_data <- fao_data %>%
        mutate(value = case_when(str_detect(indicator, pattern = "^Availability of fruits and vegetables") ~ (value*1000)/365,
                                 TRUE ~ value),
               unit = case_when(str_detect(indicator, pattern = "^Availability of fruits and vegetables") ~ "g/day",
                                TRUE ~ unit))
        
    # Clarify remaining units and indicator names
      fao_data <- fao_data %>% 
        select(-c(item)) %>%
        mutate(unit = case_when(str_detect(indicator, pattern = "^Emissions intensity") ~ "kg CO2eq/kg product",
                                str_detect(indicator, pattern = "^Total production") ~ "tonnes",
                                indicator == "Share of GDP US$" ~ "% GDP",
                                indicator == "Cost of a healthy diet (CoHD), PPP dollar per person per day" ~ "PPP dollar per day",
                                indicator == "Prevalence of unaffordability (PUA), percent" ~ "%",
                                indicator == "Per capita food supply variability (kcal/cap/day)" ~ "kcal/day",
                                indicator == "Total food system emissions (CO2eq) (AR5)" ~ "kt CO2eq (AR5)",
                                           TRUE ~ unit),
               indicator = case_when(indicator == "Share of GDP US$" ~ "Share of agriculture in GDP",
                                     indicator == "Cost of a healthy diet (CoHD), PPP dollar per person per day" ~ "Cost of a healthy diet per capita",
                                     indicator == "Prevalence of unaffordability (PUA), percent" ~ "% Population who cannot afford a healthy diet",
                                     indicator == "Per capita food supply variability (kcal/cap/day)" ~ "Food supply variability per capita",
                                     indicator == "Total food system emissions (CO2eq) (AR5)" ~ "Agri-food systems greenhouse gas emissions",
                                     TRUE ~ indicator))
      fao_data <- fao_data %>% 
        mutate(year = as.numeric(year),
               M49_code = as.numeric(M49_code))
    
    # Add ISO codes and get correct UN country name
      fao_data$ISO3 <- countrycode::countrycode(fao_data$M49_code, origin = 'un', destination = 'iso3c', warn = TRUE, nomatch = NA)
      fao_data$country2 <- countrycode::countrycode(fao_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)
      fao_data <- fao_data %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                           TRUE ~ country2)) %>%
        select(-c(country)) %>% rename(country = country2)
        
    # Eliminate observations with no ISO3 code (regional groupings)
      fao_data <- fao_data %>%
        filter(!(is.na(ISO3)))
        
    # Calculate cropland change
      croplandchange <- fao_data %>%
        filter(indicator == "Cropland area") %>%
        arrange(country, year) %>%
        group_by(country) %>%
        mutate(landarea = as.numeric(value),
               lagarea = dplyr::lag(landarea),
               fd = landarea - lagarea,
               yearonyearchange = ((landarea-lagarea)/landarea)*100,
               # Take 5 year rolling mean as the *previous* 5 years, designated using align = right
               fiveyearmean = zoo::rollmean(yearonyearchange, k = 5, fill = NA, align = "right")) %>%
        ungroup()
    
    # Rename     
      croplandchange <- croplandchange %>%
        select(-c(value, landarea,lagarea, fd, yearonyearchange)) %>%
        rename(value = fiveyearmean) %>%
        mutate(indicator = "Cropland area change",
               unit = "%")
    
    # Append to fao_data
      fao_data <- rbind(fao_data, croplandchange)
        
    # Clean up
      rm(croplandchange, toexclude, data, data2)

    # Organize
      fao_data <- fao_data[, col_order]

  # Add the food price data
    fpi <- as.data.frame(result_fpi) %>% 
      filter(Item == "Consumer Prices, Food Indices (2015 = 100)") %>%
      rename(year = Year, country = Area, unit = Unit, value = Value, M49_code = "Area.Code..M49.") %>%
      select(-c("Domain.Code","Domain","Element.Code","Item.Code","Year.Code", "Months.Code", "Element")) %>%
      filter(year >= 2000 & year <=2022) %>%
      rename(indicator = Item) %>%
      mutate(month = recode(Months,
        January = 01,
        February = 02,
        March = 03,
        April = 04,
        May = 05,
        June = 06,
        July = 07,
        August = 08,
        September = 09,
        October = 10,
        November = 11,
        December = 12)) %>%
        select(-c(Months)) %>%
        mutate(date = as.Date(paste(year, month, "01", sep = "-"), format = "%Y-%m-%d"))

    fpi <- fpi %>%
      rename(CPI_food = value) %>%
      arrange(country, date) %>%
      group_by(country) %>%
      mutate(CPI_food = as.numeric(CPI_food),
             log_CPI_food = log(CPI_food),
             laglogCPI_food = dplyr::lag(log_CPI_food),
             logfd = (log_CPI_food - laglogCPI_food),
             abs_logfd = abs(logfd)) %>%
      ungroup() 
    
    fpi <- fpi %>%
      group_by(country, year) %>%
      mutate(sdlogfd = sd(abs_logfd, na.rm = TRUE),
             meanlogfd = mean(abs_logfd, na.rm = TRUE),
             fpi_cv = (sdlogfd/meanlogfd)) %>%
      ungroup()

    fpi <- fpi %>% 
      select(-c(log_CPI_food,laglogCPI_food, logfd, abs_logfd, sdlogfd, meanlogfd)) %>%
      rename(value = fpi_cv) %>%
      mutate(indicator = "Food price volatility",
             unit = "index",
             M49_code = as.numeric(M49_code))
    
    # Remove monthly level data
      fpi <- fpi %>% select(-c(month, date))
      fpi <- fpi %>% unique()

    # Add ISO codes and get correct UN country name
      fpi$ISO3 <- countrycode::countrycode(fpi$M49_code, origin = 'un', destination = 'iso3c', warn = TRUE, nomatch = NA)
      fpi$country2 <- countrycode::countrycode(fpi$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      fpi <- fpi %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                           TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
        
    # Organize
      fpi <- fpi[, col_order]
      fpi <- fpi %>% unique()
  
    # Append to fao_data
      fao_data <- rbind(fao_data, fpi)

    # Clean up
      rm(result_fpi, fpi)
    
################################################################################

###############################################
#   SDG (UNStats)                             #
###############################################
    
    # Create data frame per indicator to wrangle
      sdg_5a1 <- result_sdg[[1]] %>% jsonlite::flatten() %>%
        select(c("seriesDescription", "geoAreaCode", "geoAreaName",
                "timePeriodStart", "value", "dimensions.Sex")) %>%
        rename(indicator = seriesDescription,
               M49_code = geoAreaCode,
               country = geoAreaName,
               year = timePeriodStart,
               sex = dimensions.Sex) %>%
        mutate(indicator = "Share of women among owners or rights-bearers of agricultural land (SDG 5.a.1)") %>%
        select(-c(sex)) %>%
        mutate(unit = "% landholdings")
      
      sdg_16102 <- result_sdg[[2]] %>% jsonlite::flatten() %>%
        select(c("seriesDescription", "geoAreaCode", "geoAreaName",
                "timePeriodStart", "value")) %>%
        rename(indicator = seriesDescription,
               M49_code = geoAreaCode,
               country = geoAreaName,
               year = timePeriodStart) %>%
        mutate(indicator = "Guarantees for public access to information (SDG 16.10.2)",
               unit = "binary")
      
    # Note that the access to information indicator brings in the latest year only, to track any change, prior years must be also added
      accessinfo2021 <- read.csv(file = file.path(data_in, "accessinfo_2021.csv"))
      accessinfo2021 <- accessinfo2021 %>%
        select(2:3, 19,21) %>% 
        mutate(indicator = "Guarantees for public access to information (SDG 16.10.2)",
               unit = "binary") %>%
        rename(value = accessinfo,
               M49_code = m49_code)
      
    # Save the 2022 values for future use
      write.csv(sdg_16102, file.path(data_out, "accessinfo_2023.csv"))

      sdg_251animal <- result_sdg[[3]] %>% jsonlite::flatten() %>%
        select(c("seriesDescription", "geoAreaCode", "geoAreaName",
                "timePeriodStart", "value")) %>%
        rename(indicator = seriesDescription,
               M49_code = geoAreaCode,
               country = geoAreaName,
               year = timePeriodStart) %>%
        filter(indicator == "Number of local breeds for which sufficient genetic resources are stored for reconstitution") %>%
        mutate(indicator = "Number of (b) animal genetic resources for food and agriculture secured in either medium- or long-term conservation facilities (SDG 2.5.1)") %>%
        mutate(unit = "number") %>%
        filter(year>=2000 & year <= 2022)
      
      sdg_251plant <- result_sdg[[4]] %>% jsonlite::flatten() %>%
        select(c("seriesDescription", "geoAreaCode", "geoAreaName",
                "timePeriodStart", "value")) %>%
        rename(indicator = seriesDescription,
               M49_code = geoAreaCode,
               country = geoAreaName,
               year = timePeriodStart) %>%
        filter(indicator == "Plant genetic resources accessions stored ex situ (number)") %>%
        mutate(indicator = "Number of (a) plant genetic resources for food and agriculture secured in either medium- or long-term conservation facilities (SDG 2.5.1)") %>%
        mutate(unit = "number")  %>%
        filter(year>=2000 & year <= 2022)
      
      sdg_611 <- result_sdg[[5]] %>% jsonlite::flatten()
      # Note that the location dimension is incorrect and all data say "ALLAREA"
      # However, after manually checking, we can see that the first observation per country-year is the all areas, the next if it exists (and does not exist for all country-years), is rural, the last is urban (see: https://unstats.un.org/sdgs/dataportal/database). 
      sdg_611 <- sdg_611 %>%
        select(c("seriesDescription", "geoAreaCode", "geoAreaName",
                "timePeriodStart", "value")) %>% 
        rename(indicator = seriesDescription,
               M49_code = geoAreaCode,
               country = geoAreaName,
               year = timePeriodStart) %>%
        group_by(country, year) %>%
        filter(row_number(value) == 1) %>%
        ungroup() %>%
        mutate(indicator = "% population using safely managed drinking water services (SDG 6.1.1)") %>%
        mutate(unit = "% population")  %>%
        filter(year>=2000 & year <= 2022)
  
      sdg_data <- rbind(sdg_5a1, sdg_16102, accessinfo2021, sdg_251animal, sdg_251plant, sdg_611)
      sdg_data <- sdg_data %>%
        mutate(value = case_when(value == "NaN" ~ "",
                                 TRUE ~ value),
               value = as.numeric(value),
               M49_code = as.numeric(M49_code)) 
    
    # Add ISO codes and get correct UN country name
      sdg_data$ISO3 <- countrycode::countrycode(sdg_data$M49_code, origin = 'un', destination = 'iso3c', warn = TRUE, nomatch = NA)
      sdg_data$country2 <- countrycode::countrycode(sdg_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      sdg_data <- sdg_data %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                           TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
    
    # Organize
      sdg_data <- sdg_data[, col_order]
    
    # Clean up
      rm(result_sdg, sdg_5a1, sdg_16102, accessinfo2021,
         sdg_251animal, sdg_251plant, sdg_611)

################################################################################

###############################################
#   Global diet quality project               #
###############################################

    gdq_data <- gdq_data %>%
      arrange(Country, Indicator, Year) %>%
      mutate(Subgroup = case_when(Indicator == "MDD-W" & Subgroup == "Female" ~ "All",
                                  TRUE ~ Subgroup)) %>%
      filter(Subgroup == "All") %>% 
      select(-c(5:6, 9:10)) %>%
      rename_with(tolower) %>%
      rename(ISO3 = iso3) %>%
      mutate(indicator = case_when(str_detect(indicator, "^Soft drink") ~ "Soft drink consumption",
                                   str_detect(indicator, "^Zero") ~ "Zero fruit or vegetable consumption, adults",
                                   str_detect(indicator, "^MDD-W") ~ "MDD-W: minimum dietary diversity for women",
                                   str_detect(indicator, "^All-5") ~ "All-5: consumption of all 5 food groups",
                                   TRUE ~ indicator),
             unit = case_when(unit == "Points" ~ "score (points out of 9)",
                              TRUE ~ unit))
    # Add M49 codes and country names
      gdq_data$M49_code <- countrycode::countrycode(gdq_data$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)
      gdq_data$country2 <- countrycode::countrycode(gdq_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      gdq_data <- gdq_data %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                           TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3))) %>%
        filter(year>=2000 & year <= 2022)
      
    # Organize
      gdq_data <- gdq_data[, col_order]

################################################################################

###############################################
#   UNICEF                                    #
###############################################
       
    MDD_iycf <- result_unicef[[1]] %>% as.data.frame() 
      MDD_iycf <- MDD_iycf[49:320,]
      MDD_iycf <- MDD_iycf %>%
        select(c(2,3,10,11)) 
      col_names <- c("ISO3", "indicator", "year", "value")
      colnames(MDD_iycf) <- col_names
      # Split ISO and country into 2 separate columns
      MDD_iycf <- MDD_iycf %>%
        separate(ISO3, into = c("ISO3", "country"),
                 sep = ": ", remove = TRUE) %>%
        mutate(indicator = "MDD (IYCF):  minimum dietary diversity for infants and young children",
               unit = "% population, 6-23 months",
               year = as.numeric(year),
               value = as.numeric(value)) %>%
        filter(!(is.na(ISO3)))
      
    zeroFV_iycf <- result_unicef[[2]] %>% as.data.frame()
      zeroFV_iycf <- zeroFV_iycf[46:195,]
      zeroFV_iycf <- zeroFV_iycf %>%
        select(c(2,3,10,11)) 
      col_names <- c("ISO3", "indicator", "year", "value")
      colnames(zeroFV_iycf) <- col_names
      # Split ISO and country into 2 separate columns
      zeroFV_iycf <- zeroFV_iycf %>%
        separate(ISO3, into = c("ISO3", "country"),
                 sep = ": ", remove = TRUE) %>%
        mutate(indicator = "Zero fruit or vegetable consumption, children 6-23 months",
               unit = "% population, 6-23 months",
               year = as.numeric(year),
               value = as.numeric(value)) %>%
        filter(!(is.na(ISO3)))

    childlabor <- result_unicef[[3]] %>% as.data.frame()
      # Eliminate region aggregates
      childlabor <- childlabor %>%
        filter(!grepl('UNICEF', REF_AREA.Geographic.area)) %>%
        filter(!grepl('UNSDG_LDC', REF_AREA.Geographic.area)) %>%
        select(c(2,3,10,11)) 
      col_names <- c("ISO3", "indicator", "year", "value")
      colnames(childlabor) <- col_names
      # Split ISO and country into 2 separate columns
      childlabor <- childlabor %>%
        separate(ISO3, into = c("ISO3", "country"),
                 sep = ": ", remove = TRUE) %>%
        mutate(indicator = "% of children 5-17 engaged in child labor",
               unit = "% population 5-17 years",
               year = as.numeric(year),
               value = as.numeric(value)) %>%
        filter(!(is.na(ISO3)))

    unicef_data <- rbind(MDD_iycf, zeroFV_iycf, childlabor)
    unicef_data <- unicef_data %>% 
      filter(year >= 2000 & year <= 2022)
    
    # Add M49 codes and country names
      unicef_data$M49_code <- countrycode::countrycode(unicef_data$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)
      unicef_data$country <- countrycode::countrycode(unicef_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA) 
      
    # Organize
      unicef_data <- unicef_data[, col_order]
  
    # Clean up
      rm(result_unicef, MDD_iycf, zeroFV_iycf, childlabor, col_names)
  
################################################################################

###############################################
#   International Budget Partnership          #
###############################################
          
    openbudget_data <- result_ibp %>%
      rename(ISO2 = COUNTRY,
             year = YEAR,
             value = "OPEN_BUDGET_INDEX") %>%
      select(-c(RANK)) %>%
      mutate(indicator = "Open Budget Index Score",
                 unit = "index")
    
    # Clean up
      rm(path, queries, options, result)
        
    # Add country name, ISO and M_49 codes
      openbudget_data$ISO3 <- countrycode::countrycode(openbudget_data$ISO2, origin = 'iso2c', destination = 'iso3c', warn = TRUE, nomatch = NA)
      openbudget_data$M49_code <- countrycode::countrycode(openbudget_data$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      openbudget_data$country <- countrycode::countrycode(openbudget_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  

    # Organize
      openbudget_data <- openbudget_data %>% select(-c(ISO2)) %>%
              filter(year >= 2000 & year <= 2022)
      openbudget_data <- openbudget_data[, col_order]
      
    # Clean up
      rm(result_ibp)

################################################################################

###############################################
#   ILOSTAT                                   #
###############################################
        
    # Clean
      unemployment <- unemployment %>%
        # Keep only rural
        filter(classif1 == "GEO_COV_RUR") %>%
        # Keep only total (not disaggregated by sex) %>%
        filter(sex == "SEX_T") %>%
        # Remove unnecessary columns
        select(c(1,6,7)) %>%
        rename(ISO3 = ref_area,
               value = obs_value,
               year = time) %>%
        # Keep only values from 2000 forward
        filter(year >= 2000) %>%
        mutate(indicator = "Unemployment rate, rural")
      
      underemployment <- underemployment %>%
        # Keep only rural
        filter(classif2 == "GEO_COV_RUR",
        # Keep only total (not disaggregated by sex) %>%
               sex == "SEX_T",
        # Keep only total age group 15-64
               classif1 == "AGE_YTHADULT_Y15-64") %>%
        # Remove unnecessary columns
        select(c(1,7,8)) %>%
        rename(ISO3 = ref_area,
               value = obs_value,
               year = time) %>%
        # Keep only values from 2000 forward
        filter(year >= 2000) %>%
        mutate(indicator = "Underemployment rate, rural")
    
    # Combine into one data frame
      ilo_data <- rbind(unemployment, underemployment) %>%
        mutate(unit = "% working age population") %>%
        filter(year >= 2000 & year <= 2022)

        
    # Add country name, ISO and M_49 codes
      ilo_data$M49_code <- countrycode::countrycode(ilo_data$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      ilo_data$country <- countrycode::countrycode(ilo_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
        
    # Organize
      ilo_data <- ilo_data[, col_order]

    # Clean up
      rm(unemployment, underemployment)
 
################################################################################

###############################################
#   Varieties of Democracy                    #
###############################################

### Get data from Varieties of Democracy R package
    vdem_codebook <- vdemdata::codebook
    variables <- c("v2x_accountability", "v2x_cspart")
    vdem_data <- vdem_data %>%
      filter(year>=2000) %>%
      select(c(1:2,4, variables)) %>%
      rename(accountability = v2x_accountability,
             cspart = v2x_cspart,
             country = country_name,
             ISO3 = country_text_id) %>%
      pivot_longer(., 4:5, names_to = "variable") %>%
      mutate(indicator = case_when(variable == "cspart" ~ "Civil society participation index",
                                   variable == "accountability" ~ "V-Dem Accountability index"),
             unit = "index") %>%
      select(-c(variable))
    
    # Fix country names
      vdem_data$country2 <- countrycode::countrycode(vdem_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      vdem_data$M49_code <- countrycode::countrycode(vdem_data$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      vdem_data <- vdem_data %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                           TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3))) %>%
        filter(year >= 2000 & year <= 2022)

    # Organize
      vdem_data <- vdem_data[, col_order]

    # Clean up
      rm(vdem_codebook)

################################################################################

###############################################
#   World Bank                                #
###############################################

    # Data cleaning
      wb_data <- wb_data %>%
        mutate(indicator = as.factor(indicator))
      wb_data <- wb_data %>%
        select(-c(iso2c, indicatorID)) %>%
        # Convert population to thousands
        mutate(value = case_when(indicator == "Population, total" ~ value/1000,
                                 TRUE ~ value)) %>%
        rename(ISO3 = iso3c,
               year = date) %>%
        mutate(unit = case_when(str_detect(indicator, pattern = "^Government") ~ "index",
                                str_detect(indicator, pattern = "^Adequacy") ~ "% of total welfare of beneficiary households",
                                str_detect(indicator, pattern = "^Coverage") ~ "% of population",
                                str_detect(indicator, pattern = "^GDP") ~ "current US$",
                                str_detect(indicator, pattern = "^Population") ~ "thousands",
                                str_detect(indicator, pattern = "^Mobile") ~ "Number per 100 people",
                                str_detect(indicator, pattern = "^PPP") ~ "LCU per international $")) %>%
        mutate(indicator = case_when(str_detect(indicator, pattern = "^Government") ~ "Government effectiveness index",
                                str_detect(indicator, pattern = "^Adequacy") ~ "Social protection adequacy",
                                str_detect(indicator, pattern = "^Coverage") ~ "Social protection coverage",
                                str_detect(indicator, pattern = "^GDP") ~ "GDP",
                                str_detect(indicator, pattern = "^Population") ~ "Total population",
                                str_detect(indicator, pattern = "^Mobile") ~ "Mobile cellular subscriptions",
                                str_detect(indicator, pattern = "^PPP") ~ "PPP conversion factor, private consumption"))
    
    # Add M49 codes and fix country names
      wb_data$country2 <- countrycode::countrycode(wb_data$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      wb_data$M49_code <- countrycode::countrycode(wb_data$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      wb_data <- wb_data %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                               TRUE ~ country2)) %>%
            select(-c("country")) %>% rename(country = country2) %>%
            filter(!(is.na(ISO3))) %>%
            filter(!(is.na(M49_code))) %>%
            filter(year >= 2000 & year <= 2022)

    # Organize
      wb_data <- wb_data[, col_order]
    
################################################################################

###############################################
#   Manually Downloaded                       #
###############################################
    
### AQUASTAT
    agwaterdraw <- read_excel(file.path(data_in, "AQUASTAT download_March2024.xlsx"),
                                        sheet = "Data")
    agwaterdraw <- agwaterdraw %>%
      select(c(3:7)) %>%
      rename(country = Area,
             indicator = Variable,
             value = Value,
             unit = Unit,
             year = Year) %>%
      filter(year>=2000) %>%
      mutate(unit = "% total renewable")
    
    # Fix country names and get M49 and ISO codes
      agwaterdraw$ISO3 <- countrycode::countrycode(agwaterdraw$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA)  
      agwaterdraw$M49_code <- countrycode::countrycode(agwaterdraw$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      agwaterdraw$country2 <- countrycode::countrycode(agwaterdraw$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      agwaterdraw <- agwaterdraw %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))

    # Organize
      agwaterdraw <- agwaterdraw[, col_order]

### FAO - DSFI
    dsfi_kcal <- read_excel(file.path(data_in, "DSFI_2010-2020_CLEAN - Jan.2024.xlsx"),
                                        sheet = "DSFI_2010-2020")
    dsfi_kcal <- dsfi_kcal %>% select(c(1:3)) %>%
      rename(country = area,
             yearrange = year,
             value = DSFIkcal) %>%
      separate(yearrange, c("range_start", "range_end")) %>%
      mutate_at(c("range_start", "range_end"), as.numeric) %>%
      # Assign the value to the midpoint year of the 3-year range
      mutate(year = range_start+1,
             unit = "index",
             indicator = "Dietary sourcing flexibility index") %>%
      select(-c("range_start", "range_end"))
    
    # Fix country names and get M49 and ISO codes
      dsfi_kcal$ISO3 <- countrycode::countrycode(dsfi_kcal$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA)  
      dsfi_kcal$M49_code <- countrycode::countrycode(dsfi_kcal$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      dsfi_kcal$country2 <- countrycode::countrycode(dsfi_kcal$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)
      dsfi_kcal <- dsfi_kcal %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))

    # Organize
      dsfi_kcal <- dsfi_kcal[, col_order]
      
### Minderoo Foundation Global Fishing Index
    fishhealth <- read_excel(file.path(data_in, "Global Fishing Index 2021 Data for Download V1.1.xlsx"),
                             sheet = "Progress and Governance results",
                             range = cell_rows(2:143))
    fishhealth <- fishhealth %>%
      select(c(1,2,5)) %>%
      mutate(year = 2021,
             indicator = "Fishery health index progress score",
             unit = "score") %>%
      rename(value = "Progress score",
             ISO3 = "ISO Code")
    
    # Fix country names and get M49 and ISO codes
      fishhealth$M49_code <- countrycode::countrycode(fishhealth$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      fishhealth$country2 <- countrycode::countrycode(fishhealth$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      fishhealth <- fishhealth %>% mutate(country2 = case_when(is.na(country2) ~ Country,
                                                     TRUE ~ country2)) %>%
        select(-c("Country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))

    # Organize
      fishhealth <- fishhealth[, col_order]
    
### IHR Food safety capacity
    foodsafety <- read_csv(file.path(data_in, "IHR SPAR_14Mar2024.csv"))
    foodsafety <- foodsafety %>% 
      select(c(2,7,8,10,30))
    cols <- c("indicator", "ISO3", "country", "year", "value")
    colnames(foodsafety) <- cols
    foodsafety <- foodsafety %>% 
      mutate(indicator = "Food safety capacity",
             unit = "score")
     
    # Fix country names and get M49 and ISO codes
      foodsafety$M49_code <- countrycode::countrycode(foodsafety$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      foodsafety$country2 <- countrycode::countrycode(foodsafety$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      foodsafety <- foodsafety %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
    
    # Organize
      foodsafety <- foodsafety[, col_order]

    # Clean up
      rm(cols)
    
### Euromonitor retail value of ultraprocessed foods
    upfretailval <- read_excel(file.path(data_in, "UPFretailval.xlsx"))
    upfretailval <- upfretailval %>%
      pivot_longer(2:6, names_to = "year", values_to = "value") %>%
      rename(country = Country) %>%
      mutate(unit = "current (nominal) US$/year",
             indicator = "Retail value of ultra-processed foods per capita")
  
    # Add M49 codes and fix country names
      upfretailval$ISO3 <- countrycode::countrycode(upfretailval$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA)  
      upfretailval$M49_code <- countrycode::countrycode(upfretailval$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      upfretailval$country2 <- countrycode::countrycode(upfretailval$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      upfretailval <- upfretailval %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
  
    # Organize
      upfretailval <- upfretailval[, col_order]
        
    # Now convert to PPP dollars
      PPP <- wb_data %>%
        filter(indicator == "PPP conversion factor, private consumption") %>%
        rename(PPP_factor = value) %>%
        select(-c(indicator, unit))
      upfretailval <- left_join(upfretailval, PPP, by = c("country", "ISO3", "M49_code", "year"))
      upfretailval <- upfretailval %>%
        mutate(value = value/PPP_factor,
               unit = "current PPP US$/year") %>%
        select(-c(PPP_factor))

    # Clean up
      rm(PPP)
    
### WFP coping strategies
    sheets <- c("2020", "2021", "2022", "2023")
    result <- lapply(sheets, function(x) read_excel(file.path(data_in, "HMU_rcsi.xlsx"),
                                        sheet = x))
    rcsi <- do.call(rbind, result)

    # Data cleaning
      rcsi <- rcsi %>% 
        select(-c(6,7)) %>%
        rename(ISO3 = country,
               country = country_name,
               value = rcsi_prevalence)
    
    # Add M49 codes and fix country names
      rcsi$M49_code <- countrycode::countrycode(rcsi$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA)  
      rcsi$country2 <- countrycode::countrycode(rcsi$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      rcsi <- rcsi %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
    
    # Identify annual maximum observed prevalence per country-year
      rcsi <- rcsi %>%
        filter(!(is.na(value))) %>%
        group_by(country, year) %>%
        mutate(maxprevalence = max(value, na.rm = TRUE)) %>%
        ungroup()
      rcsi <- rcsi %>% select(c(3:4,6:8)) %>%
        unique() %>%
        rename(value = maxprevalence)  %>%
        mutate(indicator = "Prevalence of severe coping strategies",
               unit = "% population")
        
    # Organize
      rcsi <- rcsi[, col_order]
  
    # Clean up
      rm(sheets, result)
    
### Presence of a food system pathway
    fspathway <- read.csv(file.path(data_in, "FSPathways_Mar2024.csv"))
    fspathway <- fspathway %>%
      mutate(value = 1,
             indicator = "Presence of a national food system transformation pathway",
             unit = "binary",
             year = 2022) %>%
      rename(country = Country) %>%
      select(c(country, value, indicator, unit, year))
    
    # Now add the 2023 data
      fspathway_2023 <- read.csv(file.path(data_in, "FS Pathway_Countries_2023.csv"))
      fspathway_2023 <- fspathway_2023 %>%
        select(c(Country)) %>%
        mutate(value = 1,
               indicator = "Presence of a national food system transformation pathway",
               unit = "binary",
               year = 2024) %>%
        rename(country = Country) %>%
        select(c(country, value, indicator, unit, year))   
      
    # Bind rows
      fspathway <- rbind(fspathway, fspathway_2023)
  
    # Add M49 codes and fix country names
      fspathway$ISO3 <- countrycode::countrycode(fspathway$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA) 
      fspathway$M49_code <- countrycode::countrycode(fspathway$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
      fspathway$country2 <- countrycode::countrycode(fspathway$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      fspathway <- fspathway %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
     
    # Organize
      fspathway <- fspathway[, col_order]
    
    # Clean up
      rm(fspathway_2023)
    
### Social capital - Legatum prosperity data
    socialcap <- readxl::read_excel(file.path(data_in, "2021_Full_Data_Set_-_Legatum_Prosperity_Index.xlsx"),
                                    sheet = "Indicators x 300")
    socialcap <- socialcap %>% 
      mutate_at(c("pillar_name", "element_name", "indicator_name"), as.factor) %>%
      filter(pillar_name == "Social Capital") %>%
      # keep score only
      select(-c(7:36))
    levels(socialcap$indicator_name)
    tokeep <- c("Help from family and friends when in trouble",
                "Generalised interpersonal trust",
                "Confidence in financial institutions and banks",
                "Public trust in politicians")
    socialcap <- socialcap %>%
      filter(indicator_name %in% tokeep) %>%
      select(c(1:2,6:21)) %>%
      pivot_longer(4:18, names_to = "year", 
                   values_to = "score") %>%
      mutate_at("year", str_replace, "score_", "") %>%
      mutate(year = as.numeric(year)) %>%
      rename(country = area_name, 
             ISO3 = area_code)
    
    # Now calculate the social capital as the geometric mean of remaining 4 indicators by country-year
      socialcap <- socialcap %>%
        arrange(country, year) %>%
        group_by(country, year) %>%
        mutate(socialcapital = exp(mean(log(score)))) %>%
        ungroup() 
    
    # Data cleaning
      socialcap <- socialcap %>%
        select(-c(indicator_name, score)) %>%
        unique() %>%
        rename(value = socialcapital) %>%
        mutate(indicator = "Social capital index",
               unit = "index")
    
    # Add M49 codes and fix country names
      socialcap$ISO3 <- countrycode::countrycode(socialcap$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA) 
      socialcap$M49_code <- countrycode::countrycode(socialcap$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
      socialcap$country2 <- countrycode::countrycode(socialcap$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      socialcap <- socialcap %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
    
    # Organize
      socialcap <- socialcap[, col_order]
    
    # Clean up
      rm(tokeep)
    
### Functional integrity
    
    # First import the data used previously in 2023 paper, with only 10% threshold for the year 2015
      funcinteg_10pct <- read.csv(file.path(data_in, "Apex2021_FullTable_GAUL.csv"))
      funcinteg_10pct <- funcinteg_10pct %>%
        select(c(1,8)) %>%
        rename(country = ADM0_NAME,
               value = Integ1km10) %>%
        mutate(year = 2015,
               indicator = "Functional integrity: agricultural land with minimum level of natural habitat - 10% threshold",
               unit = "% agricultural land")
    
    # Add M49 codes and fix country names
      funcinteg_10pct$ISO3 <- countrycode::countrycode(funcinteg_10pct$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA) 
      funcinteg_10pct$M49_code <- countrycode::countrycode(funcinteg_10pct$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
      funcinteg_10pct$country2 <- countrycode::countrycode(funcinteg_10pct$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      funcinteg_10pct <- funcinteg_10pct %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
    
    # Organize
      funcinteg_10pct <- funcinteg_10pct[, col_order]
    
    # Save this historical series in the tidied format
      saveRDS(funcinteg_10pct, file = file.path(data_in, "functionalintegrity_10pct_2015.rds"))
    
    # Clean up
      rm(funcinteg_10pct)
      
  # Now bring in the revised 2015 data with the 20% threshold
    funcinteg <- read_excel(file.path(data_in, "FSCI_ESA2015_20_edited.xlsx"))
    funcinteg1 <- funcinteg %>%
      select(c(5,6,10)) %>%
      rename(country = ADM0_NAME...5,
             value = "Integrity",
             ISO3 = Iso3_Code) %>%
      mutate(year = 2015,
             indicator = "Functional integrity: agricultural land with minimum level of natural habitat",
             unit = "% agricultural land")
    agland_ESA <- funcinteg %>%
      select(c(5,6,11)) %>%
      rename(country = ADM0_NAME...5,
             value = "Area_m2_Ag",
             ISO3 = Iso3_Code) %>%
      mutate(year = 2015,
             indicator = "Agricultural land area - ESA",
             unit = "sq meters")
    funcinteg <- rbind(funcinteg1, agland_ESA)
    funcinteg <- funcinteg %>%
      filter(!(country == "India" & indicator == "Agricultural land area - ESA" & value == 0))
    
    # Add M49 codes and fix country names
      funcinteg$ISO3 <- countrycode::countrycode(funcinteg$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA) 
      funcinteg$M49_code <- countrycode::countrycode(funcinteg$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
      funcinteg$country2 <- countrycode::countrycode(funcinteg$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      funcinteg <- funcinteg %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
    
    # Organize
      funcinteg <- funcinteg[, col_order]
    
    # Clean up
      rm(funcinteg1, agland_ESA)

```


$~$

Now we create the variables that we have developed or modify.

$~$

Ratio of all disasters to GDP

```{r, warning = FALSE, messages = FALSE}
### Import Em-DAT disaster data
    emdat <- readxl::read_excel(file.path(data_in, "public_emdat_2024-03-14.xlsx"),
                                    sheet = "EM-DAT Data")
    emdat <- emdat %>%
      select(c(10:11,26,41)) 
    cols <- c("ISO3", "country", "year", "damages")
    colnames(emdat) <- cols
    # Sum to the annual level
    emdat <- emdat %>%
      filter(!(is.na(damages))) %>%
      arrange(country, year) %>%
      group_by(country, year) %>%
      mutate(annual_cost = sum(damages)) %>%
      ungroup() %>%
      select(-c(damages)) %>%
      unique()
  
    # Add M49 codes and fix country names
      emdat$M49_code <- countrycode::countrycode(emdat$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
      emdat$country2 <- countrycode::countrycode(emdat$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      emdat <- emdat %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                       TRUE ~ country2)) %>%
        select(-c("country")) %>% rename(country = country2) %>%
        filter(!(is.na(ISO3)))
  
    # Join with GDP data
      GDP <- wb_data %>% filter(indicator == "GDP") %>%
        mutate(year = as.numeric(year)) %>%
        rename(GDP = value) %>%
        select(c("country", "ISO3", "M49_code", "year", "GDP"))
      emdat <- left_join(emdat, GDP, by = c("country", "ISO3", "M49_code", "year"))
      emdat <- emdat %>%
        mutate(value = (annual_cost/GDP)*100,
               indicator = "Ratio of total damages from all disasters to GDP",
               unit = "ratio") %>%
        select(-c(annual_cost, GDP))
    
    # Organize
      emdat <- emdat[, col_order]
        
    # Clean up
      rm(GDP, cols)
      
```

$~$

Agricultural land with minimum species richness

First we need to bring in the 2010 data.
```{r, warning = FALSE, messages = FALSE}
### Import the pixel count data exported from QGIS 
    # Note: HISTO_ variables denote distribution of no of pixels (1 pixel = 10x10km or 10,000 ha) for species count 1-38) within each country
    # HISTO_NODATA = non-agricultural land
      minspecies <- read.csv(file.path(data_in, "global.hist.tsr.csv"))
      minspecies <- minspecies %>%
        select(4,6,9:47) %>%
        mutate(pixelsTotal = rowSums(.[4:41]))
    
    # Collapse the dataset to the global level to find the threshold number of species at which (and above) covers 25% of global ag land (the 25% of land with the most diversity)
      minspecies_global <- minspecies %>%
        select(-c(1:3)) %>%
        summarise_all(.funs = sum) %>%
        pivot_longer(1:38, names_to = "n_species", values_to = "n_pixels") %>%
        mutate(n_species = str_replace(n_species, "HISTO_",""),
               n_species = as.numeric(n_species)) %>%
        relocate(pixelsTotal, .after = n_pixels) %>%
        mutate(share = (n_pixels / pixelsTotal),
               cum_sum = cumsum(share))
      minspecies_threshold <- minspecies_global %>%
        filter(cum_sum > 0.75) %>%
        mutate(idvar = case_when(cum_sum == min(cum_sum) ~ 1,
                                 TRUE ~ NA))
      minspecies_threshold %>% filter(idvar == 1) %>%
        select(n_species) %>%
        print()
  
    # Now add up the number of pixels per country at or above 24 species as a % of the total
      minspecies <- minspecies %>%
        select(-c(3:26)) %>%
        # Filter out areas with zero agricultural land (pixelsTotal == 0)
        filter(!(pixelsTotal==0)) %>%
        mutate(richness_sum = rowSums(.[3:17]),
               pctagland_minspecies = (richness_sum / pixelsTotal)*100) %>%
        select(1,18,20) %>%
        rename(ISO3 = iso3,
               agland_minspecies = pixelsTotal) %>%
        pivot_longer(2:3, names_to = c("indicator"),
                     values_to = c("value")) %>%
        mutate(unit = case_when(indicator == "pctagland_minspecies" ~ "% agricultural land",
                                     indicator == "agland_minspecies" ~ "pixels"),
               indicator = case_when(indicator == "pctagland_minspecies" ~ "Proportion of agricultural land with minimum level of species diversity (crop and pasture)",
                                     indicator == "agland_minspecies" ~ "Agricultural land area - Minimum species richness"),
               year = 2010) %>%
        filter(!(is.na(ISO3)))
      
    # Add M49 codes and fix country names
      minspecies$M49_code <- countrycode::countrycode(minspecies$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
      minspecies$country <- countrycode::countrycode(minspecies$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      # Filter non-UN-member states (have no country name)
      minspecies <- minspecies %>% filter(!(is.na(country))) 

    # Organize
      minspecies_2010 <- minspecies[, col_order]
            
    # Clean up
      rm(minspecies_global, minspecies_threshold, minspecies)
      
```

$~$

Now we add the 2020 data.
```{r, warning = FALSE, messages = FALSE}
### Manually downloaded data layers from MapSPAM and the Global Gridded Livestock data

    # From each of the two data sources (MapSPAM and Global Gridded Livestock product):
    # keep only the spam files ending in "A" and only the .tif file format livestock files ending in "Da")
    # Put/find these files in a subfolder called "Minimum species richness"
    # List all files in the directory with the abundance layers (assuming .tif format)
      layer_files <- list.files(path = file.path(data_in, "Min species richness layers"), 
                                pattern="*.tif$", full.names=TRUE)

    # Define a functino to process the .tif layers
      process_layer <- function(file) {
        
        # Read the raster layer
        species <- terra::rast(file)
        
        # Replace NA values with 0 (species not present)
        species[is.na(species)] <- 0
        
        # Replace non-zero values with 1 (species present)
        species[species > 0] <- 1
        
        # Return the layer with processed abundance data
        return(species)
      }
    
    
    # Read and process each layer using the defined function
      processed_layers <- lapply(layer_files, process_layer)
    
    # Stack all processed layers into a single brick object
      species_stack <- terra::rast(processed_layers)
    
    # Calculate species richness by summing across all layers
      species_richness <- sum(species_stack)
      
    # Estimating threshold (minimum richness)
      # Create data frame for calculation, only considering cells with at least 1 species
        richness_aux  <- terra::clamp(species_richness, lower=1, value=FALSE)
  
      # Estimate quantiles
        qr <- terra::global(richness_aux, quantile, na.rm=TRUE)
      
      # Define cut off point for minimum species richness as 75% quantile of global agricultural land species richness (threshold of the 25th percentile of the most diverse land)
        threshold <- qr$X75.
    
    # Identifying cells with minimum richness   
      # Create new layer
        min_species <- species_richness
      
      # Create matrix with max and min values for richness
        extremes <- terra::minmax(species_richness)
    
      #Create reclassification matrix
        m <- c(0, threshold, 0,
               threshold, extremes[2,],1) 
             
        rclmat <- matrix(m, ncol=3, byrow=TRUE)
    
      # Assign 1 for pixels with more species than the threshold, and 0 for those with fewer species.
        min_species <- terra::classify(min_species, rclmat, include.lowest=TRUE)
      
      # Write a raster that shows if each cell has the minimum number of species (1) or not (0)
        terra::writeRaster(min_species, filename=file.path(data_out,"min_species.tif"), overwrite=TRUE)

    # Assign countries to cells 
      #Read country boundaries
        #Note: requires all files of the name "world-administrative-boundaries" that come in the zip file on manual download with different format extensions (not only the .shp file listed, but the .shx, .cpg, .dbf, and .prj too.)
        countries <- terra::vect(file.path(data_in, "world-administrative-boundaries.shp"))
        
        # Extract country iso3 codes to a data frame
          iso3_codes <- data.frame(countries$iso3)
        
        # Count how many cells in each country have the minimum number of species
          pixels_min_species_per_country <- terra::zonal(min_species, countries, sum)
        
        # Identify total number of agricultural land cells per country 
        # if there is at least one species, it is ag land
          ag_land <- species_richness
          ag_land[ag_land > 0] <- 1
        
        # Add all pixels in each country to get the count
          # This is the total agricultural land consistent with this indicator
          # This should be used as the indicator of agland used to create weighted means
            agland_SPAM_GLW <- terra::zonal(ag_land, countries, sum)
        
        # Estimate proportion of cells with minimum species richness
          proportion_per_country <- cbind(iso3_codes, agland_SPAM_GLW, pixels_min_species_per_country)
          colnames(proportion_per_country) <- c("iso3", "ag_land", "min_species")
          
        # Drop territories with no ISO3 code
          proportion_per_country <- proportion_per_country %>%
            filter(!(is.na(iso3)))
          
        # Drop areas with no agricultural land
          proportion_per_country <- proportion_per_country %>%
            filter(!(ag_land == 0))
          
        # Calculate proportion of pixels per country with minimum richness
          proportion_per_country <- proportion_per_country %>% 
            dplyr::mutate(proportion_ag_land_with_min_sp = (min_species/ag_land)*100)

        # Create data frame and harmonize
          minspecies_2020 <- dplyr::select(proportion_per_country, -c(min_species))
          minspecies_2020 <- minspecies_2020 %>%
            pivot_longer(2:3, names_to = c("indicator"), values_to = c("value")) %>%
            mutate(unit = case_when(indicator == "proportion_ag_land_with_min_sp" ~ "% agricultural land",
                                         indicator == "ag_land" ~ "pixels"),
                   indicator = case_when(indicator == "proportion_ag_land_with_min_sp" ~ "Proportion of agricultural land with minimum level of species diversity (crop and pasture)",
                                         indicator == "ag_land" ~ "Agricultural land area - Minimum species richness"),
                   year = 2020) %>%
            rename(ISO3 = iso3)
          
    # Add M49 code and country names
      minspecies_2020$M49_code <- countrycode::countrycode(minspecies_2020$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
      minspecies_2020$country <- countrycode::countrycode(minspecies_2020$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
      # Drop ISO3 codes with no UN country name - indicates it is a territory
        minspecies_2020 <- minspecies_2020 %>% 
          filter(!(is.na(country)))
            
    # Organize
      minspecies_2020 <- minspecies_2020[, col_order]
        
            
    # Clean up
      rm(proportion_per_country, pixels_min_species_per_country, ag_land, agland_SPAM_GLW, species_richness, min_species, iso3_codes, processed_layers, species_stack, layer_files, process_layer, m, rclmat, extremes, richness_aux, qr, countries)
    
```
    
$~$

Presence of any health-related food environment policies

```{r, warning = FALSE, messages = FALSE}
# Import the full NOURISHING database
  foodenviropol <- read.csv(file.path(data_in, "policy-export22-Mar-2024.csv"))
    
# Classification
  foodenviropol$Policy.area <- as.factor(foodenviropol$Policy.area)
  levels(foodenviropol$Policy.area)
    
  # Keep food environment policy areas only
  food_enviro <- c("Nutrition label standards and regulations on the use of claims and implied claims on food",
                   "Offer healthy food and set standards in public institutions and other specific settings",
                   "Use economic tools to address food affordability and purchase incentives",
                   "Restrict food advertising and other forms of commercial promotion",
                   "Improve nutritional quality of the whole food supply",
                   "Set incentives and rules to create a healthy retail and food service environment")
  
  # Classify status as mandatory or voluntary, includes specific text strings identified through iterative manual review of the policy action field until no records were left unclassified
  foodenviropol <- foodenviropol %>%
    filter(Policy.area %in% food_enviro)

    foodenviropol <- foodenviropol %>%
      mutate(type = case_when(Policy.area == "Nutrition label standards and regulations on the use of claims and implied claims on food" ~ "regulatory",
                              Policy.area == "Offer healthy food and set standards in public institutions and other specific settings" ~ "regulatory",
                              Policy.area == "Use economic tools to address food affordability and purchase incentives" ~ "economic",
                              Policy.area == "Restrict food advertising and other forms of commercial promotion" ~ "regulatory",
                              Policy.area == "Improve nutritional quality of the whole food supply" ~ "regulatory",
                              Policy.area == "Set incentives and rules to create a healthy retail and food service environment" ~ "regulatory")) %>%
      mutate(status = case_when(str_detect(Sub.policy.area, regex('mandatory', ignore_case = T)) ~ "mandatory",
                                   str_detect(Sub.policy.area, regex('voluntary', ignore_case = T)) ~ "voluntary",
                              type == "economic" ~ "mandatory",
                              TRUE ~ "")) %>%
      mutate(status = case_when(str_detect(Policy.action, regex('mandator*', ignore_case = T)) & status == "" ~ "mandatory",    
                              str_detect(Policy.action, regex('compuls*', ignore_case = T)) & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('law', ignore_case = T)) & status == "" ~ "mandatory",
                              str_detect(Policy.action, 'Act') ~ "mandatory",
                              str_detect(Policy.action, regex('legislat*', ignore_case = T)) & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Regulation*')) & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('EU-wide rules', ignore_case = T)) & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('ban', ignore_case = T)) & status == "" ~ "mandatory",
                              #str_detect(Policy.action, regex('standards', ignore_case = T)) & status == "" ~ "mandatory",
                              #str_detect(Policy.action, regex('rules', ignore_case = T)) & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('voluntar*', ignore_case = T)) & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('guideline*', ignore_case = T)) & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('guidance*', ignore_case = T)) & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('recommend*', ignore_case = T)) & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('award*', ignore_case = T)) & status == "" ~ "voluntary",
                              Sub.policy.area == "Bans specific to vending machines in schools" & status == "" ~ "mandatory",
                              Sub.policy.area == 'Clearly visible "interpretative" labels and warning labels' & status == "" ~ "mandatory",
                              Sub.policy.area == "Government engage with industry to develop self-regulation to restrict food marketing to children" & Country == "UK" & status == "" ~ "mandatory",
                              Sub.policy.area == "Warning labels on menus and displays in out-of-home venues" & Country == "South Korea" & status == "" ~ "voluntary",
                              Sub.policy.area == "Standards in social support programmes" & Country == "Mexico" & status == "" & str_detect(Policy.action, regex('Subsidised milk', ignore_case = T)) ~ "voluntary",
                              str_detect(Policy.action, regex('memorandum of', ignore_case = T)) & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('discretion of local authorities', ignore_case = T)) & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('participating schools', ignore_case = T)) & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('The Food Labelling Guide', ignore_case = T)) & Country == "USA" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('The Northern Fruit and Vegetable Program', ignore_case = T)) & Country == "Canada" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('Manitoba', ignore_case = T)) & Sub.policy.area == "Fruit & vegetable initiatives in schools" & Country == "Canada" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('British Columbia', ignore_case = T)) & Sub.policy.area == "Fruit & vegetable initiatives in schools" & Country == "Canada" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('Healthier vending policy', ignore_case = T)) & Country == "Ireland" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('ORDIN Nr. 25/2019', ignore_case = T)) & Country == "Romania" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('The National Prevention act', ignore_case = T)) & Country == "Netherlands" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Healthy Eating in Higher Education', ignore_case = T)) & Country == "Portugal" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('SGF Healthy Living Programme', ignore_case = T)) & Country == "UK" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('Nutrition, Health and Related Claims Standard 1.2.7', ignore_case = T)) & (Country == "Australia" | Country == "New Zealand") & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Crunch&amp;Sip', ignore_case = T)) & Country == "Australia" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Nutrition standards in hospitals', ignore_case = T)) & Country == "Croatia" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Health protection requirements', ignore_case = T)) & Country == "Estonia" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Standards on level of fat in meat', ignore_case = T)) & Country == "Ghana" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Salt levels limits for food served in hospitals', ignore_case = T)) & Country == "Latvia" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Salt levels limits for food served in hospitals', ignore_case = T)) & Country == "Latvia" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Swiss quality standards', ignore_case = T)) & Country == "Switzerland" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('School Fruit and Vegetable Scheme', ignore_case = T)) & Country == "UK" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('Santa Clara|California USA|Berkeley|Davis|Stockton|Perris', ignore_case = T)) & Country == "USA" & status == "" ~ "voluntary",
                              str_detect(Policy.action, regex('San Francisco|NYC|WIC|Detroit', ignore_case = T)) & Country == "USA" & status == "" ~ "mandatory",
                              str_detect(Policy.action, regex('at*discretion of', ignore_case = T)) ~ "voluntary",
                              TRUE ~ status))

  # Identify and eliminate subnational policies
  foodenviropol <- foodenviropol %>%
    mutate(national = case_when(str_detect(Policy.action, regex('local level|subnational', ignore_case = T)) & (!(str_detect(Policy.action, regex('EU|national', ignore_case = T)))) ~ "subnational",
                                str_detect(Policy.action, regex('San Francisco|NYC|New York City|Philadelphia|Detroit|Boston|Puerto Rico|Maine|Santa Clara|Berkeley|Davis|Stockton|Perris|California|Seattle|Oakland|Boulder|Albany|Navajo Nation|Cook County|Massachusetts|San Bernadino|Arkansas', ignore_case = T)) & Country == "USA" ~ "subnational",
                                str_detect(Policy.action, regex('Crunch&amp;Sip', ignore_case = T)) & Country == "Australia" ~ "subnational",
                                str_detect(Policy.action, regex('local health district|Queensland|Western district|New South Wales', ignore_case = T)) & Country == "Australia" ~ "subnational",
                                str_detect(Policy.action, regex('Belgium (French region)', ignore_case = T)) & Country == "Belgium" ~ "subnational",
                                str_detect(Policy.action, regex('Ontario|British Columbia|Manitoba|North Canada', ignore_case = T)) & Country == "Canada" ~ "subnational",
                                str_detect(Policy.action, regex('Cook Islands', ignore_case = T)) & Country == "New Zealand" ~ "subnational",
                                str_detect(Policy.action, regex('Catalonia', ignore_case = T)) & Country == "Spain" ~ "subnational",
                                Country == "Taiwan" ~ "subnational",
                                str_detect(Policy.action, regex('Abu Dhabi', ignore_case = T)) & Country == "UAE" ~ "subnational",
                                str_detect(Policy.action, regex('Brighton|England|Scotland|Wales|Northern Ireland', ignore_case = T)) & Country == "UK" ~ "subnational",
                                TRUE ~ "national"))
          
  # Data cleaning
  foodenviropol <- foodenviropol %>%
    mutate(Country = case_when(str_detect(Policy.action, regex('Nauru', ignore_case = T)) ~ "Nauru",
                               str_detect(Policy.action, regex('Palau', ignore_case = T)) ~ "Palau",
                               Country == "Taiwan" ~ "China",
                               TRUE ~ Country))
  
  # Country names and codes
  foodenviropol$ISO3 <- countrycode::countrycode(foodenviropol$Country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA)  
  foodenviropol$M49_code <- countrycode::countrycode(foodenviropol$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
  foodenviropol$country2 <- countrycode::countrycode(foodenviropol$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
  foodenviropol <- foodenviropol %>% mutate(country2 = case_when(is.na(country2) ~ Country,
                                                   TRUE ~ country2)) %>%
    select(-c("Country")) %>% rename(country = country2) %>%
    filter(!(is.na(ISO3)))
  
  # Export classification
  write.csv(foodenviropol, file.path(data_out, "Food environment policies classification.csv"))
  
  # Create the final indicator
  foodenviropol <- foodenviropol %>%
    select(-c(1:5)) %>%
    mutate(across(1:3, as.factor)) %>%
    filter(national == "national" & status == "mandatory") %>%
    unique() %>%
    select(-c(national, status)) %>%
    mutate(value = 1) %>%
    relocate(value, .after = type) %>%
    pivot_wider(id_cols = c("country", "ISO3", "M49_code"), names_from = "type", values_from = "value") %>%
    mutate(both = rowSums(across(4:5), na.rm = TRUE),
           both = case_when(both == 1 ~ NA,
                            both == 2 ~ 1),
           regulatory = case_when(both == 1 ~ NA,
                                  TRUE ~ regulatory),
           economic = case_when(both == 1 ~ NA,
                                  TRUE ~ economic))
  
  foodenviropol <- foodenviropol %>%
    mutate(value = case_when(regulatory == 1 ~ "regulatory",
                             economic == 1 ~ "economic",
                             both == 1 ~ "both"),
           indicator = "Presence of national health-related food environment policies",
           unit = "categorical",
           year = 2023) %>%
    select(-c(4:6))

# Organize
  foodenviropol <- foodenviropol[, col_order]

```

$~$

Get the 2021 Right to food data

```{r, warning = FALSE, messages = FALSE}
# Import the dataset from the 2023 baseline paper
  rtf_2021 <- read.csv(file.path(data_in, "righttofood_2021.csv"))

# Establish the categories
  rtfcategories <- c("Explicit protection of the right to food or directive of state policy","Some other implicit recognition, codification of international statutes, or other pertinent provisions", "None")
  rtf_2021 <- rtf_2021 %>%
    select(c(1:3,9,16)) %>%
    rename(ISO3 = ISO,
           M49_code = m49_code,
           value = righttofood) %>%
    mutate(unit = "categorical",
           indicator = "Degree of legal recognition of the Right to Food",
           year = 2021)
  rtf_2021$value <- factor(rtf_2021$value, levels = 1:3, labels = rtfcategories)
  
# Add M49 codes and fix country names
  rtf_2021$country2 <- countrycode::countrycode(rtf_2021$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
  rtf_2021 <- rtf_2021 %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                   TRUE ~ country2)) %>%
    select(-c("country")) %>% rename(country = country2) %>%
    filter(!(is.na(ISO3)))

# Organize
  rtf_2021 <- rtf_2021[, col_order]
```

$~$

Right to food - 2024

```{r, warning = FALSE, messages = FALSE}
# Import dataset created by reviewing https://www.fao.org/right-to-food-around-the-globe/constitutional-level-of-recognition/en/
  rtf <- readxl::read_excel(file.path(data_in, "Rigth-to-Food_Dataset_2024.xlsx"),
                                  sheet = "Sheet1")
  rtf <- rtf %>% select(-c(3)) %>%
    mutate(value = as.factor(degree_of_recognition)) %>%
    select(-c(degree_of_recognition)) %>%
    mutate(year = 2024,
           indicator = "Degree of legal recognition of the Right to Food",
           unit = "categorical")
  
  # Classify into 3 categories so that there is one value per country per year:
    # Explicit protection of the right to food or directive of state policy
    # Some other implicit recognition, codification of international statues, or other pertinent provisions
    # None
  
  # Identify the highest level of recognition so there is one value per country-year
  rtf2 <- rtf %>% 
    mutate(valtemp = 1) %>%
    pivot_wider(names_from = value, values_from = valtemp) %>%
    mutate(value_select = "",
           value_select = case_when((`Explicit protection of the right to adequate food` == 1 | `Directive principles of state policy` == 1) ~ "Explicit protection of the right to adequate food",
                                    value_select == "" & (`National status of international obligations` == 1 | `Other pertinent provisions for the realization of the right to adequate food` == 1) ~ "Some other implicit recognition, codification of international statues, or other pertinent provisions",
                                    value_select == "" ~ "None",
                                    TRUE ~ value_select))
  rtf2 <- rtf2 %>% select(c(country, year, value_select))
  rtf <- left_join(rtf, rtf2, by = c("country", "year"))
  rtf <- rtf %>%
    select(-c(value)) %>%
    unique() %>%
    rename(value = value_select)
  rtf$value <- factor(rtf$value, levels = 1:3, labels = rtfcategories)
  

# Add ISO3 & M49 codes and fix country names
  rtf$ISO3 <- countrycode::countrycode(rtf$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA)  
  rtf$M49_code <- countrycode::countrycode(rtf$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
  rtf$country2 <- countrycode::countrycode(rtf$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
  rtf <- rtf %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                   TRUE ~ country2)) %>%
    select(-c("country")) %>% rename(country = country2) %>%
    filter(!(is.na(ISO3)))

# Organize
  rtf <- rtf[, col_order]
  rtf <- rbind(rtf_2021, rtf)

# Clean up
  rm(rtf_2024, rtf_2021, rtf2, rtfcategories)

```

$~$

Percent of urban population living in a city that has signed onto the Milan Urban Food Policy Pact. First get 2020 data.
```{r, warning = FALSE, messages = FALSE}
# Get 2020 data
  mufpp_2020 <- read.csv(file.path(data_in, "mufpp_pop_2020.csv"))
  mufpp_2020 <- mufpp_2020 %>%
    select(c(1:2,5:6,9)) %>%
    rename(ISO3 = ISO) %>%
    pivot_longer(4:5, names_to = "indicator", values_to = "value") %>%
    mutate(unit = case_when(indicator == "mufppurbshare" ~ "% urban population",
                                 indicator == "pop_u" ~ "thousands"),
           indicator = case_when(indicator == "mufppurbshare" ~ "% urban population living in cities signed onto the Milan Urban Food Policy Pact",
                                 indicator == "pop_u" ~ "Urban population"),
           year = 2020)
  
  # Add M49 codes and fix country names
  mufpp_2020$M49_code <- countrycode::countrycode(mufpp_2020$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
  mufpp_2020$country2 <- countrycode::countrycode(mufpp_2020$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
  mufpp_2020 <- mufpp_2020 %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                   TRUE ~ country2)) %>%
    select(-c("country")) %>% rename(country = country2) %>%
    filter(!(is.na(ISO3)))

# Organize
  mufpp_2020 <- mufpp_2020[, col_order]

```

$~$

Now calculate updated data for 2023 (latest Landscan population data available are 2022, but the city list was updated Jan 2024).
```{r, warning = FALSE, messages = FALSE}
      mufpp_2023 <- mufpp_2023 %>%
        select(c(1,3,4)) %>%
        group_by(cities.country, pop_u) %>%
        summarize(mufpp_pop = sum(city_pop)) %>%
        ungroup() %>%
        dplyr::mutate(mufppurbshare = round((mufpp_pop / pop_u)*100, 2),
                      pop_u = pop_u/1000) %>%
        rename(country = cities.country) %>%
        select(c(1,2,4)) %>%
        unique() %>%
        pivot_longer(2:3, names_to = "indicator", values_to = "value") %>%
        mutate(unit = case_when(indicator == "mufppurbshare" ~ "% urban population",
                                indicator == "pop_u" ~ "thousands"),
               indicator = case_when(indicator == "mufppurbshare" ~ "% urban population living in cities signed onto the Milan Urban Food Policy Pact",
                                     indicator == "pop_u" ~ "Urban population"),
               year = 2023) # Assign to 2023, populations from 2022 but city update from Jan 2024
      
      # Add M49 codes and fix country names
        mufpp_2023$country2 <- countrycode::countrycode(mufpp_2023$country, origin = 'country.name', destination = 'un.name.en', warn = TRUE, nomatch = NA)  
        mufpp_2023 <- mufpp_2023 %>% mutate(country2 = case_when(is.na(country2) ~ country,
                                                                   TRUE ~ country2)) %>%
          select(-c("country")) %>% 
          rename(country = country2) 
        mufpp_2023$ISO3 <- countrycode::countrycode(mufpp_2023$country, origin = 'country.name', destination = 'iso3c', warn = TRUE, nomatch = NA) 
        mufpp_2023$M49_code <- countrycode::countrycode(mufpp_2023$ISO3, origin = 'iso3c', destination = 'un', warn = TRUE, nomatch = NA) 
        
      # Organize
        mufpp_2023 <- mufpp_2023[, col_order]
        
```

$~$

Save individual files by data source of cleaned data
```{r, warning = FALSE, messages = FALSE}
  save(mufpp_2020, mufpp_2023, rtf, foodenviropol, minspecies_2020, minspecies_2010,
       emdat, funcinteg, wb_data, vdem_data, ilo_data, openbudget_data, unicef_data,
       gdq_data, sdg_data, fao_data, mufpp_2023, fishhealth, foodsafety, 
       upfretailval, rcsi, fspathway, socialcap, dsfi_kcal, agwaterdraw,
       file = file.path(data_out, "Cleaned data by source_individual files.RData"))
```

#### Compile final dataset

```{r, warning = FALSE, messages = FALSE}
# Load all the data frames if needed
  load(file = file.path(data_out, "Cleaned data by source_individual files.RData"))

    # Bind all rows
      dfs = sapply(.GlobalEnv, is.data.frame) 
      FSCI_2024 <- do.call(rbind, mget(names(dfs)[dfs]))

# Rectangularize the data (make sure there is a country-year row for every indicator with NA if there is no data)
  # Save country info and units to add to new records created in rectangularization
    countryinfo <- FSCI_2024 %>% select(c(country, ISO3, M49_code)) %>% unique()
    units <- FSCI_2024 %>% select(c(indicator, unit)) %>% unique()
  # Rectangularize
    FSCI_2024 <- FSCI_2024 %>% tidyr::complete(country, indicator, year) 
      # Add "None" for categorical variables
        FSCI_2024 <- FSCI_2024 %>%
          mutate(value = case_when(indicator == "Presence of national health-related food environment policies" & year == 2023 & is.na(value) ~ "none",
                                   TRUE ~ value),
                 value = case_when(indicator == "Presence of a national food system transformation pathway" & year %in% c(2022,2024) & is.na(value) ~ "0", 
                                   TRUE ~ value),
                 value = case_when(indicator == "Guarantees for public access to information (SDG 16.10.2)" & is.na(value) & year == 2022 ~ "0",
                                   TRUE ~ value),
                 value = case_when(indicator == "% urban population living in cities signed onto the Milan Urban Food Policy Pact" & is.na(value) & year == 2023 ~ "0",
                                   TRUE ~ value))
  # Clean up
    FSCI_2024 <- FSCI_2024 %>% filter(!(is.na(country))) %>%
      filter(!(is.na(year))) %>%
      select(-c(ISO3, M49_code, unit))
    FSCI_2024 <- left_join(FSCI_2024, countryinfo, by = "country")
    FSCI_2024 <- left_join(FSCI_2024, units, by = "indicator")
  
# Organize
  FSCI_2024 <- FSCI_2024[, col_order]

# Join additional codebook data and organizing variables
  codebook <- read_excel(here::here("Supplementary Data 1 - Metadata and Codebook.xlsx"), 
                         sheet = "Codebook")
  country_classification <- read_excel(here::here("Supplementary Data 1 - Metadata and Codebook.xlsx"), 
                         sheet = "Country classification") %>%
    # Remove M49 code because it is already in the data frame
    select(-c(12))
  
  # Merge in codebook information
    FSCI_2024 <- left_join(FSCI_2024, codebook, by = c("indicator" = "variable_label")) %>%
      # Remove country to bring in UN member state names
      select(-c(country)) %>%
      filter(!(ISO3 == "" | is.na(M49_code)))
    FSCI_2024 <- left_join(FSCI_2024, country_classification, by = c("ISO3", "M49_code"))
  
  # Fix characters in Turkey, Cote D'Ivoire, and Curacao
    FSCI_2024 <- FSCI_2024 %>%
      mutate(country = case_when(country == "Turkiye" ~ "Trkiye",
                                 country == "Cote D'Ivoire" ~ "Cte d'Ivoire",
                                 country == "Curacao" ~ "Curaao",
                                 TRUE ~ country))

# Remove any non-UN member states and observations prior to 2000
  FSCI_2024 <- FSCI_2024 %>%
    filter(member_state == "YES") %>%
    filter(year>=2000) %>%
    select(-c(20:25))
  
# Arrange data
  FSCI_2024 <- FSCI_2024 %>%
    relocate(country, .before = "M49_code") 
  
  FSCI_2024 <- FSCI_2024[with(FSCI_2024, order(country, year, variable_order)),]
    
# Other data management
  FSCI_2024 <- FSCI_2024 %>%
    unique() %>%
    mutate(across(5, as.numeric)) %>%
    mutate(across(c(1,3:4, 8:9, 12:19), as.factor)) %>%
      # Make sure there is no duplicate value for India in 2015 for ESA Agricultural land (from functional integrity dataset)
    filter(!(country == "India" & indicator == "Agricultural land area - ESA" & value == 0))

# Clean up
  rm(codebook, country_classification, countryinfo, units)

# Now add in the weighted means (global, by income group, and by region)
  # Filter out the non-numerical indicators
    data <- FSCI_2024 %>%
      filter(!(unit == "categorical")) %>%
      mutate(value = as.numeric(value))

  # Mutate the weighting variables wide
    weightvars <- data %>%
      filter(is.na(indicator_order)) %>%
      select(-c(unit, short_label, indicator, 10:16,19:20)) %>%
      pivot_wider(id_cols = c("country", "year", "M49_code", "ISO3", "income_group", "FSCI_region"),
                  names_from = variable,
                  values_from = value)

  # Filter weighting variables from the long data and merge back in wide form
    data <- data %>%
      filter(!(is.na(indicator_order))) %>%
      left_join(., weightvars, by = c("country", "year", "ISO3", "M49_code", "income_group", "FSCI_region"))
  
  # Calculate weighted mean
    # Define weights
    data <- data %>%
      #mutate(mean_weighting = as.character(mean_weighting)) %>%
      mutate(weight = case_when(mean_weighting == "totalpop" ~ totalpop,
                                mean_weighting == "production_beef" ~ production_beef,
                                mean_weighting == "production_cerealsexclrice" ~ production_cerealsexclrice,
                                mean_weighting == "production_cowmilk" ~ production_cowmilk,
                                mean_weighting == "production_rice" ~ production_rice,
                                mean_weighting == "agland" ~ agland,
                                mean_weighting == "agland_ESA" ~ agland_ESA,
                                mean_weighting == "agland_minspecies" ~ agland_minspecies,
                                mean_weighting == "GDP" ~ GDP,
                                mean_weighting == "landarea" ~ landarea,
                                mean_weighting == "pop_u" ~ pop_u, 
                                mean_weighting == "cropland" ~ cropland,
                                mean_weighting == "animals_beef" ~ animals_beef, 
                                mean_weighting == "animals_cowmilk" ~ animals_cowmilk, 
                                mean_weighting == "areaharvested_cereals" ~ areaharvested_cereals, 
                                mean_weighting == "areaharvested_fruit" ~ areaharvested_fruit, 
                                mean_weighting == "areaharvested_veg" ~ areaharvested_veg, 
                                mean_weighting == "unweighted" ~ 1,
                                TRUE ~ NA),
             # Replace 0 as NA (weight = 0 happens when there is no area harvested, for example)
             weight = case_when(weight == 0 ~ NA,
                                TRUE ~ weight))
    # Compute
      globalmeans <- data %>%
        arrange(indicator, year) %>%
        # Global mean
          group_by(indicator, year) %>%
          filter(!(is.na(value))) %>%
          filter(!(is.na(weight))) %>%
          mutate(globalmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
          ungroup() %>%
        select(c(5,8,40)) %>%
        unique()
    
      # Regional mean
        regionmeans <- data %>%
          group_by(indicator, year, FSCI_region) %>%
          filter(!(is.na(FSCI_region))) %>%
          filter(!(is.na(value))) %>%
          filter(!(is.na(weight))) %>%
          mutate(regionmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
          ungroup() %>%
          select(c(5,8,18,40)) %>%
          unique()
  
      # Income group mean
        incomemeans <- data %>%
          group_by(indicator, year, income_group) %>%
          filter(!(is.na(income_group))) %>%
          filter(!(is.na(value))) %>%
          filter(!(is.na(weight))) %>%
          mutate(incomegrpmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
          ungroup() %>%
          select(c(5,8,17,40)) %>%
          unique()
    
  # Merge the means back into the FSCI_2024 dataframe
    FSCI_2024 <- FSCI_2024 %>%
      # Remove the weighting variables in the long data
      filter(!(is.na(indicator_order)))
      # Remove excess variables from the dataframe with the weighting variables wide
      data <- data %>%
        select(c(1,5,8,21:39)) 
      # Now join in with the weight variables as columns
      FSCI_2024 <- left_join(FSCI_2024, data, by = c("country", "year", "variable"))
      # Now add the grouped weighted means 
      FSCI_2024 <- left_join(FSCI_2024, globalmeans, by = c("year", "variable"))
      FSCI_2024 <- left_join(FSCI_2024, regionmeans, by = c("year", "variable", "FSCI_region"))
      FSCI_2024 <- left_join(FSCI_2024, incomemeans, by = c("year", "variable", "income_group")) 
      
  # Remove extreme values for change in cropland >-200% (Montenegro 2013-2017)
      FSCI_2024 <- FSCI_2024 %>%
        mutate(value = case_when(indicator == "Cropland area change" & country == "Montenegro" & year %in% 2013:2017 ~ "",
                                 TRUE ~ value))
      
  # Clean up
    rm(data, weightvars, globalmeans, incomemeans, regionmeans)

  # remove functions
    rm(getdata2, getdata3, getdata_fao, getdata_sdg)
      
# Save dataset
  saveRDS(FSCI_2024, file = file.path(data_out, "FSCI_2024.rds"))
  readr::write_csv(FSCI_2024, file = file.path(data_out, "FSCI_2024.csv.gz"))
      
```
