---
title: "FSCI 2024 Analysis"
author: "Kate Schneider"
date: "`r Sys.Date()`"
output: word_document
---

### *Overall Objectives*
This script contains all analysis tables and figures for the 2024 FSCI paper.

```{r setup, warning = FALSE, messages = FALSE, results = "hide", echo = TRUE}
### Setup required to knit this script into a markdown document
    
### Load packages
    # R studio should prompt the installation of any packages not loaded on the instance where this script has been opened
    
    # Data management and multipurpose packages
    library(data.table)
    library(kableExtra)
    library(knitr)
    library(stringr)
    library(tidyverse)
    library(stats)
    library(broom)
    library(here)

    # Data visualization packages
    library(tmap)
    library(sf)
    library(rnaturalearth)
    library(grid)
    library(cowplot)
    library(flextable)
    library(ggeffects)
    library(ggforce)
    library(igraph)
    library(ggraph)

### File management
  
    # Set the root folder to the project root so that all file paths are relative to the main project folder
    knitr::opts_knit$set('./')
    
    # Set relative directory paths
    data_out <- here::here("Output Data")
    figtab_out <- here::here("Figures & Tables")

### Set preferred options
    
    # Set the treatment of numbers to numerical (avoids scientific notation from showing in results)
    options(scipen = 999)
  
    # Set echo = FALSE for all code chunks will prevent the code from printing in the output file as the default setting (set to TRUE where relevant)
    knitr::opts_chunk$set(echo = FALSE)

### Functions
    
    # Create a "not in" operator
    `%notin%` <- Negate(`%in%`) 
    
### Color palettes
    themes_colors <- c("#21908dff", "#3b518bff", "#97a4b2", "#fde725ff", "#5cc863ff")
    categories <- c("#97ebdb", "#0086ad", "#005582", "gray80")
    income_colors <- c("Low income" = "#97a4b2", 
                      "Lower middle income"  = "#41B6C4", 
                      "Upper middle income" = "#1D91C0", 
                      "High income" = "#0C2C84",
                      "Global mean" = "gray25")
    region_colors <- c("Central Asia" = "#CC6677FF",
                      "Eastern Asia" = "#332288FF",                  
                      "Latin America & Caribbean" = "#DDCC77FF",     
                      "Northern Africa & Western Asia" = "#117733FF", 
                      "Northern America and Europe" = "#88CCEEFF",    
                      "Oceania" = "#882255FF",
                      "South-eastern Asia" =  "#44AA99FF",            
                      "Southern Asia" = "#999933FF",                  
                      "Sub-Saharan Africa" = "#AA4499FF",
                       "Global mean" = "gray25")

    
### Organization
    col_order <- c("country", "M49_code", "ISO3", "indicator", 
           "year", "value", "unit")
    row_order <- c("country", "year", "variable_order")
```

#### Load data files
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Supplementary data file 1: "Supplementary Data 1 - Metadata and Codebook.xlsx" contained in root R project folder. This is an Excel workbook best viewed in Excel and provides metadata for reference.

# Supplementary data file 2:
FSCI_2024 <- readRDS(file = file.path(data_out, "FSCI_2024.rds"))

# Expert elicitation:
load(file = file.path(data_out, "Interactions_ExpertElicititation.RData"))

# Literature search results dataset:
  search_results <- readxl::read_excel(path = file.path(data_out, "Search results_screened.xlsx"))
```

$~$

# Main manuscript figures

#### Figure 1. Trends over time
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Regress each variable on time to get average linear trend
  # List of indicators with less than 3 years of data (cannot compute the regression model)
    oneyear <- c("Functional integrity",
                 "Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", "Female landholdings", "Minimum dietary diversity, child", 
                              "Minimum dietary diversity, women", "NCD-Protect", "NCD-Risk", "Reduced coping strategies", 
                              "Social protection adequacy", "Social protection coverage", "Soft drink consumption", "Zero fruits or vegetables, adult", "Zero fruits or vegetables, child")
  
  # Set up data
    data <- FSCI_2024 %>%
      # Remove categorical indicators
      filter(!(unit == "categorical")) %>%
      # Remove indicators with only one year of data
      filter(!(short_label %in% oneyear)) %>%
      # Remove survey data
      filter(!(short_label %in% surveyindicators)) %>%
      select(country, short_label, year, value, indicator_order, 
             desirable_direction, theme, weight, 
             FSCI_region, income_group) %>%
      filter(!(is.na(value))) %>%
      mutate(value = as.numeric(value),
             country = as.character(country)) %>%
      ungroup() %>%
      filter(!(is.na(value)))
    
  # Now normalize the data
    data <- data %>%
      group_by(short_label) %>%
      mutate(normvalue = (value - min(value)) / (max(value) - min(value)),
             normvalue = normvalue * 100) %>%
      ungroup() 
    
    data$short_label <- factor(data$short_label)
    data$country <- factor(data$country)
    data <- droplevels(data)
    
    # Initialize an empty list to store results
      results_list <- list()

    # Iterate over unique levels of short_label
      for (i in unique(data$short_label)) {
        dat <- filter(data, short_label == i)
        
        # Check if there are enough data points for the model
          model <- lm(normvalue ~ year + FSCI_region, data = dat, weights = weight)
          result <- broom::tidy(model)
          result <- result

          # Add 95% confidence interval to the result
          conf_int <- broom::confint_tidy(model)
          result <- cbind(result, conf_int)
          
          # Add short_label to the result
          result$short_label <- i
          
          # Add result to list
          results_list[[i]] <- result 
          }
    
    # Combine results into a single data frame
    all_results <- do.call(rbind, results_list)
  
# Export table of full results
    
    regress_tbl <- all_results %>%
      filter(term != "(Intercept)") %>%
      filter(!str_detect(term, "^FSCI_region")) %>%
      select(-c(statistic, term)) %>%
      mutate(across(1:5, round, 5)) %>%
      relocate(short_label, .before = estimate)
    
    # Add indicator order to sort
    data2 <- data[, c("short_label", "indicator_order", "desirable_direction")]
    data2 <- data2 %>% unique()
    regress_tbl <- left_join(regress_tbl, data2, by = ("Indicator" = "short_label"))
    regress_tbl <- regress_tbl %>% arrange(indicator_order) %>%
      select(-c(indicator_order))
    
    # Name the columns nicely
    col_names <- c( "Indicator", "Coef.", "SE", "p val.", "95% Conf. Int.", "merge", "Desirable direction")
    colnames(regress_tbl) <- col_names
    
# Remove the intercepts
    all_results2 <- all_results %>%
      filter(!str_detect(term, "^FSCI_region")) %>%
      filter(term != "(Intercept)") %>%
      rename(pval = "p.value")
    
# Add stars for p-value
    all_results2 <- all_results2 %>%
      mutate(star = case_when(pval < 0.001 ~ "***",
                              pval >= 0.001 & pval < 0.01 ~ "**",
                              pval >= 0.01 & pval < 0.05 ~ "*",
                              pval >= 0.05 ~ "")) %>%
      select(short_label, estimate, conf.low, conf.high, star, pval) %>%
      mutate(across(2:4, round, 3)) # This rounding step is consequential for the results - important to make a choice about how many digits to keep to "round to zero"
    
    # Merge in the theme and variable order 
    data2 <- data[, c("short_label", "indicator_order", "theme", "desirable_direction")]
    data2 <- data2 %>% unique()
    all_results2$short_label <- factor(all_results2$short_label)
    all_results2 <- left_join(all_results2, data2, by = c("short_label"))
    # Add a variable to indicate whether the change is flat, in the right direction, or in the wrong direction
    all_results2 <- all_results2 %>%
      mutate(Progress = case_when(pval >= 0.05 ~ "No change",
                                  desirable_direction == 1 & pval < 0.05 & estimate > 0 ~ "Desirable change",
                                  desirable_direction == -1 & pval < 0.05 & estimate < 0 ~ "Desirable change",
                                  desirable_direction == 1 & pval < 0.05 & estimate < 0 ~ "Undesirable change",
                                  desirable_direction == -1 & pval < 0.05 & estimate > 0 ~ "Undesirable change",
                                  desirable_direction == 1 & pval <0.05 & estimate == 0 ~ "No change",
                                  desirable_direction == -1 & pval <0.05 & estimate == 0 ~ "No change",
                                  TRUE ~ "No change"),
             Progress = as.factor(Progress))


# Plot the estimates
  p1 <- all_results2 %>%
       filter(estimate < 11) %>%
      ggplot(., aes(y = fct_reorder(short_label, desc(estimate)), x = estimate)) + 
      geom_point(aes(color = Progress)) +
      geom_errorbarh(aes(xmin = conf.low, xmax = conf.high, color = Progress), width = 0.1) +
      geom_text(aes(label = star, x = conf.high, color = Progress), hjust = -.1) +
      scale_color_manual(values = c("forestgreen","gray85",  "darkred")) +
      scale_y_discrete(limits=rev) +
      geom_vline(xintercept = 0) +
      theme_classic() +
      labs(y = "",
           x = "Average percent change per year (95% Confidence Interval)",
           caption = "*** p< 0.001, ** p< 0.01, * p < 0.05") +
      theme(plot.caption = element_text(hjust = -0.88),
            plot.margin = unit(c(0,0,0,0), "cm"),
            legend.position = "none")

  # Now create the legend to show progress
    forlegend <- all_results2 %>%
      ggplot(., aes(y = fct_reorder(short_label, desc(estimate)), x = 1)) +
      geom_point(aes(color = Progress), size = 4) +
      scale_color_manual(values = c( "forestgreen","gray85", "darkred"),
                         guide = guide_legend()) +
      scale_y_discrete(limits=rev) +
      scale_x_discrete(c(1,1)) +
      theme_classic() +
      theme(legend.text = element_text(size=12),
            legend.title.align = 0,
            legend.position = "right", 
            legend.justification = "left",
            legend.direction = "horizontal",
            legend.title = element_text(size=12),
            plot.margin = unit(c(0,0,0,0), "cm"),
            legend.margin=unit(c(0,0,0,0), "cm"))
    legend <- get_legend(forlegend)

# Save the plot as .png
    png(file.path(figtab_out, "Figure 1.png"), width = 7.5, height = 10, unit = "in", res = 300)
    cowplot::plot_grid(p1, legend, nrow = 2, rel_heights = c(22,1), align = "v")
    dev.off()
    
# Clean up
  rm(legend, p1, all_results2, data2, col_names, regress_tbl, all_results, data, surveyindicators, oneyear, Indicator, i, model, conf_int)  
  
```

$~$

#### Figure 2. Map of food environment policies
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
  # Filter data to visualize
    data <- FSCI_2024 %>% 
      filter(indicator == "Presence of national health-related food environment policies" &
               year == 2023) %>%
      rename(iso_a3_eh = ISO3) %>% # to match map country identifier
      select(c(iso_a3_eh, value)) %>%
      mutate(value = case_when(value == "economic" ~ "Economic",
                               value == "regulatory" ~ "Mandatory regulations",
                               value == "both" ~ "Both", 
                               value == "none" ~ "None"),
             value = factor(value, levels = c("Economic", "Mandatory regulations", "Both", "None")))
  
  # World map 
    World <- rnaturalearth::ne_countries(scale = 110,  returnclass = c("sf"))  
    
  # Merging map with data
  data_simple <- merge(World, data, by='iso_a3_eh',  duplicateGeoms = TRUE)
  
  #Turn off s2 processing to avoid invalid polygons
  sf::sf_use_s2(FALSE)
  
  # Create map
    map <- tm_shape(data_simple) + 
      tm_fill("value",
                  style = "cat",
                  palette = categories,
                  title="") + 
      tm_borders(col = "gray60", lwd = 0.5, lty = "solid", alpha = NA) +
      tm_layout(frame = FALSE, legend.outside=TRUE)
  
  map
  
  tmap_save(map, file.path(figtab_out, "Figure 2.png"), width = 10, height = 3.5, dpi=300, units = "in")
  
# Clean up
  rm(data_simple, map, World)

```

$~$

#### Figure 3. Closest connection between each pair of indicators
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
  plot <- Interactions_ExpertElicit_AdjacencyMatrix %>% 
    # Create a fifth value for identity so that they can be colored white
    mutate(relationship = case_when(from == to ~ 4,
                                    TRUE ~ relationship)) %>%
    # Create an ordering variable so X-axis is grouped by theme
    group_by(from) %>%
    mutate(var_order = seq_along(from)) %>%
    ungroup() %>%
    # Create an ordering variable for theme
    mutate(theme_order = case_when(from_theme == "Diets, Nutrition, & Health" ~ 1,
                                   from_theme == "Environment, Natural resources, & Production" ~ 2,
                                   from_theme == "Livelihoods, Poverty, & Equity" ~ 3,
                                   from_theme == "Governance" ~ 4,
                                   from_theme == "Resilience" ~ 5)) %>%
  ggplot(aes(y = fct_reorder(from, from_order), x = fct_reorder(to, var_order), fill = as.factor(relationship))) +
    geom_tile() +
    ggforce::facet_col(vars(fct_reorder(from_theme,theme_order)), scales = "free_y", space = "free") +
    scale_y_discrete(limits = rev) +
    scale_x_discrete(position = "top") +
    scale_fill_manual(values = c("gray80", "#2c7fb8","#9ecae1", "#deebf7", "white"),
                      labels = c("None (or indirect via 3 or more)", "Direct", "Indirect via 1 indicator", "Indirect via 2 indicators")) +
    theme_classic() +
    guides(fill = FALSE) +
    theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            axis.text.x = element_text(angle = 90, size = 7),
            axis.text.x.top = element_text(vjust = 0.05, hjust = 0),
            axis.text.y = element_text(size = 7),
          plot.caption.position = "plot") +
    geom_vline(xintercept = seq(1.5, length(unique(Interactions_ExpertElicit_AdjacencyMatrix$to)) - 0.5, 1), 
             linetype = "solid", 
             color = "gray50", 
             size = 0.25) +
    geom_hline(yintercept = seq(1.5, length(unique(Interactions_ExpertElicit_Bidirect$from)) - 0.5, 1), 
           linetype = "solid", 
           color = "gray50", 
           size = 0.25) 

  forlegend <- Interactions_ExpertElicit_AdjacencyMatrix %>% 
    # Create an ordering variable so X-axis is grouped by theme
    group_by(from) %>%
    mutate(var_order = seq_along(from)) %>%
    ungroup() %>%
    # Create an ordering variable for theme
    mutate(theme_order = case_when(from_theme == "Diets, Nutrition, & Health" ~ 1,
                                   from_theme == "Environment, Natural resources, & Production" ~ 2,
                                   from_theme == "Livelihoods, Poverty, & Equity" ~ 3,
                                   from_theme == "Governance" ~ 4,
                                   from_theme == "Resilience" ~ 5)) %>%
  ggplot(aes(y = fct_reorder(from, from_order), x = fct_reorder(to, var_order), fill = as.factor(relationship))) +
    geom_tile() +
    ggforce::facet_col(vars(fct_reorder(from_theme,theme_order)), scales = "free_y", space = "free") +
    scale_y_discrete(limits = rev) +
    scale_x_discrete(position = "top") +
    scale_fill_manual(values = c("gray80", "#2c7fb8","#9ecae1", "#deebf7"),
                      labels = c("None (or indirect via 3 or more)", "Direct", "Indirect via 1 indicator", "Indirect via 2 indicators")) +
    theme_classic() +
    theme(legend.position = "right",
          legend.direction = "horizontal",
          legend.key = element_rect(color="black"),
          legend.text = element_text(size = 9),
          legend.title = element_text(size = 10),
            axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            axis.text.x = element_text(angle = 90, size = 7),
            axis.text.x.top = element_text(vjust = 0.05, hjust = 0),
            axis.text.y = element_text(size = 7),
          plot.caption.position = "plot") +
    labs(fill = "Closest connection")
  legend <- cowplot::get_legend(forlegend)
  
  # Add legend and save 
  png(file.path(figtab_out, "Figure 3.png"), width = 7.5, height = 10, unit = "in", res = 300)
    cowplot::plot_grid(plot, legend, nrow = 2, rel_heights = c(20,1), align = 'v')
  dev.off()
  
# Clean up
  rm(plot, legend, forlegend)
  
```

$~$

#### Figure 4. Literature search results

$~$

```{r, warning = FALSE, messages = FALSE, cache = TRUE}
  # Aggregate to search
  gov_litcounts <- search_results %>%
    select(c(1:2))
  col_names <- c("indicator_1", "indicator_2")
  colnames(gov_litcounts) <- col_names
  gov_litcounts <- gov_litcounts %>%
    mutate(count = 1) %>%
    group_by(indicator_1, indicator_2) %>%
    summarise(count = sum(count)) 
    # fix capitalization to merge with theme info
      # Function to capitalize the first letter of the first word
      capitalize_first <- function(x) {
        sub("^([a-z])", "\\U\\1", x, perl = TRUE)
      }

      # Apply the function to each element
        gov_litcounts$indicator_1 <- sapply(gov_litcounts$indicator_1, capitalize_first)
        gov_litcounts$indicator_2 <- sapply(gov_litcounts$indicator_2, capitalize_first)  

    # Bring in the organizing information
      themes_info1 <- Interactions_ExpertElicit_AdjacencyMatrix %>% select(1,4,6) %>%
        rename(indicator_1 = from,
               theme1 = from_theme,
               order1 = from_order) %>%
        unique()
      themes_info2 <- Interactions_ExpertElicit_AdjacencyMatrix %>% select(1,4,6) %>%
        rename(indicator_2 = from,
               theme2 = from_theme,
               order2 = from_order) %>%
        unique()
      gov_litcounts <- gov_litcounts %>%
        mutate(indicator_1 = case_when(indicator_1 == "Food system transformation pathway" ~ "Food system pathway",
                                       TRUE ~ indicator_1),
               indicator_2 = case_when(indicator_2 == "Food system transformation pathway" ~ "Food system pathway",
                                       TRUE ~ indicator_2))
      gov_litcounts <- left_join(gov_litcounts, themes_info1, by = "indicator_1")
      gov_litcounts <- left_join(gov_litcounts, themes_info2, by = "indicator_2")
      
  # Now for any pairs that are only one governance indicator - move it to the first column
      gov_litcounts2 <- gov_litcounts %>%
        filter(theme2 == "Governance" & theme1 != "Governance") %>%
         rename_with(~sub("1$", "4", .) %>% 
                sub("2$", "3", .) %>% 
                sub("3$", "1", .) %>% 
                sub("4$", "2", .),
              ends_with(c("1", "2"))) 
      col_order <- names(gov_litcounts)
      gov_litcounts2 <- gov_litcounts2[, col_order]
      
      # Now remove these rows from the main dataset
      gov_litcounts <- gov_litcounts %>%
        filter(!(theme2 == "Governance" & theme1 != "Governance"))
      
      # And merge the reordered data back
      gov_litcounts <- rbind(gov_litcounts, gov_litcounts2)
      gov_litcounts <- gov_litcounts %>%
        arrange(order1)

 # Winsorize the counts at 2500 and relabel the end of the label >2500
    gov_litcounts <- gov_litcounts %>%
       mutate(count = case_when(count > 1000 ~ 1000,
              TRUE ~ count))
    ggplot(gov_litcounts, aes(x=count)) + geom_histogram()
    
    gov_litcounts$theme2 <- ordered(gov_litcounts$theme2, levels = c("Diets, Nutrition, & Health", "Environment, Natural resources, & Production", "Livelihoods, Poverty, & Equity", "Governance", "Resilience"))


# Plot
  plot <- gov_litcounts %>% 
    # Create an ordering variable so X-axis is grouped by theme
    group_by(indicator_1) %>%
    mutate(var_order = seq_along(indicator_1)) %>%
    ungroup() %>%
  ggplot(aes(y = fct_reorder(indicator_1, order1), x = fct_reorder(indicator_2, order2), 
             color = as.factor(theme2), size = count)) +
    geom_point() +
    scale_x_discrete(position = "top") +
    scale_color_manual(values = themes_colors) +
    scale_size_continuous(range = c(1, 12),
                          breaks = c(1, 10, 25, 75, 150, 300, 500, 1000),
                          labels = c(1, 10, 25, 75, 150, 300, 500, "1000+")) +     
    theme_classic() +
    theme(legend.position = "bottom",
          legend.text = element_text(size = 8),
          legend.title = element_text(size =8),
          axis.title.x = element_blank(),
          axis.title.y = element_blank(),
          axis.text.x = element_text(angle = 90, size = 9),
          axis.text.x.top = element_text(vjust = 0.05, hjust = 0),
          axis.text.y = element_text(size = 9),
          legend.box="vertical",
          plot.caption.position = "plot",
          legend.location = "plot") +
    labs(size = "Number of publications",
         color = "") +
    guides(color = guide_legend(order = 2, nrow = 2, byrow = TRUE, 
                                override.aes = list(size = 3)),
           size = guide_legend(order = 1, nrow = 1))
  
  # Now add a summary row
   gov_litcount_total <- gov_litcounts %>% 
      plyr::arrange(order1, order2) %>%
      select(c(1,3)) %>%
      group_by(indicator_1) %>%
      summarise(tot_count = sum(count))
   # add back indicator order
      gov_litcounts2 <- gov_litcounts %>%
        select(c(indicator_1, order1)) %>%
        unique()
      
   gov_litcount_total <- left_join(gov_litcount_total, gov_litcounts2, by = "indicator_1") %>%
     mutate(Total = "Total Publications")
  
   table <- gov_litcount_total %>%
            ggplot(aes(y = fct_reorder(indicator_1, order1), x = Total)) +
            geom_text(aes(label = tot_count)) +
            scale_x_discrete(position = "top", c(1,1)) +
            theme_classic() +
            theme(plot.margin = margin(0,0,0,-1),
                  legend.position = "none",
                  axis.title.x = element_blank(),
                  axis.title.y = element_blank(),
                  axis.text.x = element_text(angle = 90, size = 10, face = "bold"),
                  axis.text.x.top = element_text(vjust = 0.05, hjust = 0),
                  axis.text.y = element_blank(),
                  axis.ticks.y = element_blank(),
                  axis.line.y = element_blank())
  
  
  png(file.path(figtab_out, "Figure 4.png"), width = 10, height = 7.5, unit = "in", res = 300)
    cowplot::plot_grid(plot, table, ncol = 2, rel_widths = c(10,1), align = 'h')
  dev.off()

# Clean up
  rm(plot, table, gov_litcount_tbl, gov_litcount_total, gov_litcounts, gov_litcounts2, themes_info1, themes_info2)

```

$~$

# Extended Data

$~$

#### Extended Data Tables 1 and 2
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Create data frame with latest data point per country-indicator
# Only includes data since 2010 for realistic relevance to current situation. Some indicators have data for 2023 and 2024 but not yet data available for the weighting variable needed to compute weighted means. These data points are not included.
  latest_df <- FSCI_2024 %>%
    filter(!(is.na(value))) %>%
    filter(!(is.na(weight))) %>%
    filter(year >= 2010) %>%
    group_by(country, indicator) %>%
    mutate(maxyear = max(year)) %>%
    filter(year == maxyear) %>%
    ungroup() %>%
  unique()

# Multiple the damages indicator by 100 for display purposes (else it rounds to 0 when printing table with one significant digit)
latest_df <- latest_df %>%
  mutate(value = as.numeric(value),
         value = case_when(indicator == "Ratio of total damages from all disasters to GDP" ~ value * 1000,
                           TRUE ~ value))

# Save latest data point per country-year for metadata
  for_metadata <- latest_df %>%
    select(c(1,5,9, 10)) %>%
    arrange(country, indicator_order) %>%
    select(-c(indicator_order)) %>%
    pivot_wider(names_from = short_label, values_from = year, values_fill = NA) %>%
    mutate(across(c(2:57), as.character),
           across(c(2:57), na_if, "NULL"))
  writexl::write_xlsx(for_metadata, file.path(data_out, "Latest data point per country-indicator.xlsx"))
  # This sheet is manually added to Supplementary Data 1 - Metadata and Codebook 

# Recalculate weighted means
  # Remove annually calculated variables
    latest_df <- latest_df %>%
      select(-c(ends_with("mean")))

    # Compute new weighted means
    globalmeans <- latest_df %>%
      arrange(indicator) %>%
      filter(!(unit == "categorical")) %>%
      mutate(value = as.numeric(value)) %>%
      filter(!(is.na(value))) %>%
      # Global mean
        group_by(indicator) %>%
        filter(!(is.na(value))) %>%
        filter(!(is.na(weight))) %>%
        mutate(globalmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
        ungroup() %>%
      select(c(4, 41)) %>%
      unique()
    
      # Regional mean
      regionmeans <- latest_df %>%
        arrange(indicator, FSCI_region) %>%
        filter(!(unit == "categorical")) %>%
        filter(!(is.na(FSCI_region))) %>%
        mutate(value = as.numeric(value)) %>%
        filter(!(is.na(value))) %>%
        group_by(indicator, FSCI_region) %>%
        mutate(regionmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
        ungroup() %>%
        select(c(4,18,41)) %>%
        unique()

      # Income group mean
      incomemeans <- latest_df %>%
        arrange(indicator, income_group) %>%
        filter(!(unit == "categorical")) %>%
        filter(!(is.na(income_group))) %>%
        mutate(value = as.numeric(value)) %>%
        filter(!(is.na(value))) %>%
        group_by(indicator, income_group) %>%
        mutate(incomegrpmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
        ungroup() %>%
        select(c(4,17,41)) %>%
        unique()

# Merge back into the dataset
    latest_df <- left_join(latest_df, globalmeans, by = "indicator")
    latest_df <- left_join(latest_df, regionmeans, by = c("indicator", "FSCI_region"))
    latest_df <- left_join(latest_df, incomemeans, by = c("indicator", "income_group"))
    
# Now keep only one row per indicator with the metadata and means
    latest_df <- latest_df %>%
      select(c("indicator", "short_label", "theme", "domain", "unit", "FSCI_region", "income_group", "mean_weighting", "desirable_direction", ends_with("mean")), "indicator_order") %>%
      unique() %>%
      rename(Indicator = indicator,
             Unit = unit,
             Theme = theme,
             Domain = domain,
             "Desirable direction of change" = desirable_direction,
             "Global mean" = globalmean) %>%
      mutate(mean_weighting = case_when(mean_weighting == "agland" ~ "Agricultural land area",
                                        mean_weighting == "agland_ESA" ~ "Agricultural land area - ESA",
                                        mean_weighting == "agland_minspecies" ~ "Agricultural land area - Minimum species richness",
                                       str_detect(mean_weighting, "^animals") ~ "Producing animals",
                                       str_detect(mean_weighting, "^areaharvested") ~ "Area harvested",
                                       str_detect(mean_weighting, "^production") ~ "Total production",
                                       mean_weighting == "cropland" ~ "Cropland",
                                       mean_weighting == "landarea" ~ "Land area",
                                       mean_weighting == "pop_u" ~ "Urban population",
                                       mean_weighting == "totalpop" ~ "Total population",
                                       mean_weighting == "unweighted" ~ "Unweighted",
                                       TRUE ~ mean_weighting)) %>%
      rename('Weighted by' = mean_weighting)
    
# Income group and metadata table
    inc_meta_tbl <- latest_df %>%
      select(-c("FSCI_region", "regionmean")) %>%
      unique() %>%
      filter(!(is.na(income_group))) %>%
      pivot_wider(names_from = income_group, values_from = incomegrpmean) %>%
      arrange(indicator_order) %>%
      select(-c(indicator_order, short_label)) %>%
      relocate('Global mean', .after = 'High income') %>%
      relocate('Upper middle income', .after = 'Lower middle income') %>%
      relocate(Indicator, .after = Domain) %>%
      mutate(across(7:11, round, 1))
    
    flextable::set_flextable_defaults(
      font.family = 'Times New Roman',
      font.size = 10)
    table1 <- flextable::flextable(inc_meta_tbl) %>% autofit() %>%
      set_table_properties(layout = "autofit")
        
    # Save table
      save_as_docx(table1, path = file.path(figtab_out, "ED Table 1_Inc Group + Metadata.docx"), orient = "landscape")
      
# Regional means table
    regions_tbl <- latest_df %>%
      select(-c("income_group", "incomegrpmean")) %>%
      unique() %>%
      filter(!(is.na(FSCI_region))) %>%
      pivot_wider(names_from = FSCI_region, values_from = regionmean) %>%
      arrange(indicator_order) %>%
      select(-c(indicator_order, Indicator)) %>%
      relocate('Global mean', .after = 'Central Asia') %>%
      relocate(short_label, .after = Domain) %>%
      mutate(across(7:16, round, 1)) %>%
      rename('Indicator' = short_label)
    
    table2 <- flextable::flextable(regions_tbl) %>% autofit() %>%
      set_table_properties(layout = "autofit")
        
    # Save table
      save_as_docx(table2, path = file.path(figtab_out, "ED Table 2_Regional Means.docx"), orient = "landscape")
      
# Clean up
  rm(latest_df, globalmeans, incomemeans, regionmeans,inc_meta_tbl, regions_tbl, table1, table2)

```


#### Extended Data Table 3
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Aggregate to search
  gov_litcounts <- search_results %>%
    select(c(1:2))
  col_names <- c("indicator_1", "indicator_2")
  colnames(gov_litcounts) <- col_names
  gov_litcounts <- gov_litcounts %>%
    mutate(count = 1) %>%
    group_by(indicator_1, indicator_2) %>%
    summarise(count = sum(count)) 
    # fix capitalization to merge with theme info
      # Function to capitalize the first letter of the first word
      capitalize_first <- function(x) {
        sub("^([a-z])", "\\U\\1", x, perl = TRUE)
      }

      # Apply the function to each element
        gov_litcounts$indicator_1 <- sapply(gov_litcounts$indicator_1, capitalize_first)
        gov_litcounts$indicator_2 <- sapply(gov_litcounts$indicator_2, capitalize_first)  

    # Bring in the organizing information
      themes_info1 <- Interactions_ExpertElicit_AdjacencyMatrix %>% select(1,4,6) %>%
        rename(indicator_1 = from,
               theme1 = from_theme,
               order1 = from_order) %>%
        unique()
      themes_info2 <- Interactions_ExpertElicit_AdjacencyMatrix %>% select(1,4,6) %>%
        rename(indicator_2 = from,
               theme2 = from_theme,
               order2 = from_order) %>%
        unique()
      gov_litcounts <- gov_litcounts %>%
        mutate(indicator_1 = case_when(indicator_1 == "Food system transformation pathway" ~ "Food system pathway",
                                       TRUE ~ indicator_1),
               indicator_2 = case_when(indicator_2 == "Food system transformation pathway" ~ "Food system pathway",
                                       TRUE ~ indicator_2))
      gov_litcounts <- left_join(gov_litcounts, themes_info1, by = "indicator_1")
      gov_litcounts <- left_join(gov_litcounts, themes_info2, by = "indicator_2")
      
  # Now for any pairs that are only one governance indicator - move it to the first column
      gov_litcounts2 <- gov_litcounts %>%
        filter(theme2 == "Governance" & theme1 != "Governance") %>%
         rename_with(~sub("1$", "4", .) %>% 
                sub("2$", "3", .) %>% 
                sub("3$", "1", .) %>% 
                sub("4$", "2", .),
              ends_with(c("1", "2"))) 
      col_order <- names(gov_litcounts)
      gov_litcounts2 <- gov_litcounts2[, col_order]
      
      # Now remove these rows from the main dataset
      gov_litcounts <- gov_litcounts %>%
        filter(!(theme2 == "Governance" & theme1 != "Governance"))
      
      # And merge the reordered data back
      gov_litcounts <- rbind(gov_litcounts, gov_litcounts2)
      gov_litcounts <- gov_litcounts %>%
        arrange(order1)

# Export table 
    flextable::set_flextable_defaults(
      font.family = 'Times New Roman',
      font.size = 10)
    gov_litcount_tbl <- gov_litcounts %>% 
      plyr::arrange(order1, order2) %>%
      select(c(1:3))
    col_names <- c("Indicator 1", "Indicator 2", "Number of results")
    colnames(gov_litcount_tbl) <- col_names
    table1 <- flextable::flextable(gov_litcount_tbl) %>% autofit() %>%
      set_table_properties(layout = "autofit")
        
    # Save table
      save_as_docx(table1, path = file.path(figtab_out, "ED Table 3.docx"), orient = "portrait")
      
# Clean up
    rm(gov_litcount_tbl, table1, gov_litcounts2, gov_litcounts, themes_info2, themes_info1)  
      
```

$~$

# Supplementary Information

$~$

#### SI Table 1
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Regress each variable on time to get average linear trend
  # List of indicators with less than 3 years of data (cannot compute the regression model)
    oneyear <- c("Functional integrity",
                 "Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", "Female landholdings", "Minimum dietary diversity, child", 
                              "Minimum dietary diversity, women", "NCD-Protect", "NCD-Risk", "Reduced coping strategies", 
                              "Social protection adequacy", "Social protection coverage", "Soft drink consumption", "Zero fruits or vegetables, adult", "Zero fruits or vegetables, child")
  
  # Set up data
    data <- FSCI_2024 %>%
      # Remove categorical indicators
      filter(!(unit == "categorical")) %>%
      # Remove indicators with only one year of data
      filter(!(short_label %in% oneyear)) %>%
      # Remove survey data
      filter(!(short_label %in% surveyindicators)) %>%
      select(country, short_label, year, value, indicator_order, 
             desirable_direction, theme, weight, 
             FSCI_region, income_group) %>%
      filter(!(is.na(value))) %>%
      mutate(value = as.numeric(value),
             country = as.character(country)) %>%
      ungroup() %>%
      filter(!(is.na(value)))
    
  # Now log the data
    data <- data %>%
      group_by(short_label) %>%
      mutate(normvalue = (value - min(value)) / (max(value) - min(value)),
             normvalue = normvalue * 100) %>%
      ungroup() 
    
    data$short_label <- factor(data$short_label)
    data$country <- factor(data$country)
    data <- droplevels(data)
    
    # Initialize an empty list to store results
      results_list <- list()

    # Iterate over unique levels of short_label
      for (i in unique(data$short_label)) {
        dat <- filter(data, short_label == i)
        
        # Check if there are enough data points for the model
          model <- lm(normvalue ~ year + FSCI_region, data = dat, weights = weight)
          result <- broom::tidy(model)
          result <- result

          # Add 95% confidence interval to the result
          conf_int <- broom::confint_tidy(model)
          result <- cbind(result, conf_int)
          
          # Add short_label to the result
          result$short_label <- i
          
          # Add result to list
          results_list[[i]] <- result 
          }
    
    # Combine results into a single data frame
    all_results <- do.call(rbind, results_list)
    
    regress_tbl <- all_results %>%
      filter(term != "(Intercept)") %>%
      filter(!str_detect(term, "^FSCI_region")) %>%
      select(-c(statistic, term)) %>%
      mutate(across(1:5, round, 5)) %>%
      relocate(short_label, .before = estimate)
    
    # Add indicator order to sort
    data2 <- data[, c("short_label", "indicator_order", "desirable_direction")]
    data2 <- data2 %>% unique()
    regress_tbl <- left_join(regress_tbl, data2, by = ("Indicator" = "short_label"))
    regress_tbl <- regress_tbl %>% arrange(indicator_order) %>%
      select(-c(indicator_order))
    
    # Add stars for p-value
    regress_tbl <- regress_tbl %>%
      mutate(star = case_when(p.value < 0.001 ~ "***",
                              p.value >= 0.001 & p.value < 0.01 ~ "**",
                              p.value >= 0.01 & p.value < 0.05 ~ "*",
                              p.value >= 0.05 ~ "")) %>%
      mutate(across(2:6, round, 3)) %>% # This rounding step is consequential for the results - important to make a choice about how many digits to keep to "round to zero"
      relocate(star, .after = p.value)
    
    # Name the columns nicely
    col_names <- c( "Indicator", "Coef.", "SE", "p val.", "merge1", "95% Conf. Int.", "merge2", "Desirable direction")
    colnames(regress_tbl) <- col_names
    

# Export table of full results
    
    SItable1 <- flextable::flextable(regress_tbl) %>% autofit() %>%
      set_table_properties(layout = "autofit")
        
    # Save table
      save_as_docx(SItable1, path = file.path(figtab_out, "SI Table 1_Regression results.docx"), orient = "landscape")
      
# Clean up
    rm(surveyindicators, oneyear, SItable1, regress_tbl, data2, all_results, results_list, data)
```

$~$

#### SI Table 2 Direct and indirect indicator connections and total network density
```{r, warning = FALSE, messages = FALSE, echo = TRUE}
  sumdf <- Interactions_ExpertElicit_AdjacencyMatrix %>% 
    # Create an ordering variable so X-axis is grouped by theme
      group_by(from) %>%
      mutate(var_order = seq_along(from)) %>%
      ungroup() %>%
    # Create an ordering variable for theme
      mutate(theme_order = case_when(from_theme == "Diets, Nutrition, & Health" ~ 1,
                                     from_theme == "Environment, Natural resources, & Production" ~ 2,
                                     from_theme == "Livelihoods, Poverty, & Equity" ~ 3,
                                     from_theme == "Governance" ~ 4,
                                     from_theme == "Resilience" ~ 5)) 
    # Now sum the connections
      direct <- sumdf %>%
        filter(relationship == 1) %>%
        group_by(from) %>%
        summarise(Direct = sum(relationship)) %>%
        ungroup()
      via1 <- sumdf %>%
        filter(relationship == 2) %>%
        mutate(relationship = 1) %>%
        group_by(from) %>%
        summarise("Indirect via 1" = sum(relationship))  %>%
        ungroup()
      via2 <- sumdf %>%
        filter(relationship == 3) %>%
        mutate(relationship = 1) %>%
        group_by(from) %>%
        summarise("Indirect via 2" = sum(relationship))  %>%
        ungroup()
      density <- direct %>%
        mutate("Network density" = round((Direct / 49),2))
        
    # Join
      sumdf <- sumdf %>%
        select(from, from_theme, from_order, theme_order) %>%
        unique()
      sumdf <- left_join(sumdf, density, by = "from")
      sumdf <- left_join(sumdf, via1, by = "from")
      sumdf <- left_join(sumdf, via2, by = "from")
      sumdf <- sumdf %>%
        relocate(`Network density`, .after = `Indirect via 2`) %>%
        mutate("Total connections" = rowSums(across(5:7), na.rm = TRUE)) %>%
        mutate(`Percent direct` = round((Direct / `Total connections`) * 100, 0)) %>%
        relocate(`Percent direct`, .after = `Total connections`) %>%
        relocate(`Network density`, .after = `Percent direct`)

# Create table
  sumdf <- sumdf %>%
    relocate(from_theme, .before = "from") %>%
    rename(Theme = from_theme,
           Indicator = from) %>%
    select(-c(3:4)) %>%
    arrange(-`Network density`)
  sumdf[is.na(sumdf)] <- 0
  flextable::flextable(sumdf) %>%
    save_as_docx(path = file.path(figtab_out, "SI Table 2_Interactions results.docx"))
  
# Clean up
  rm(sumdf, density, via1, via2, direct)
      
```

$~$

#### SI FIgures 1-5 Time trends by region
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Set up the data
    oneyear <- c("Functional integrity",
                 "Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", "Female landholdings", "Minimum dietary diversity, child", "Minimum dietary diversity, women", "NCD-Protect", "NCD-Risk", "Reduced coping strategies", "Social protection adequacy", "Social protection coverage", "Soft drink consumption", "Zero fruits or vegetables, adult", "Zero fruits or vegetables, child")
  
  # Set up data
    data <- FSCI_2024 %>%
      # Remove categorical indicators
      filter(!(unit == "categorical")) %>%
      # Remove indicators with only one year of data
      filter(!(short_label %in% oneyear)) %>%
      # Remove survey data
      filter(!(short_label %in% surveyindicators)) %>%
      select(country, short_label, year, value, indicator_order, 
             desirable_direction, theme, weight, 
             FSCI_region, income_group) %>%
      filter(!(is.na(value))) %>%
      mutate(value = as.numeric(value),
             country = as.character(country)) %>%
      ungroup() %>%
      filter(!(is.na(value)))
    
  # Now normalize the data
    data <- data %>%
      group_by(short_label) %>%
      mutate(normvalue = (value - min(value)) / (max(value) - min(value)),
             normvalue = normvalue * 100) %>%
      ungroup() 
    
    data$short_label <- factor(data$short_label)
    data$country <- factor(data$country)
    data <- droplevels(data)

    # Initialize an empty list to store results
      results_list <- list()
      predict_list <- list()

    # Iterate over unique levels of short_label
      for (i in unique(data$short_label)) {
        dat <- data %>% filter(short_label == i)
        
        # Check if there are enough data points for the model
          model <- lm(normvalue ~ year*FSCI_region, data = dat, weights = weight)
          result <- broom::tidy(model)
          predict <- ggeffects::ggpredict(model, c("year", "FSCI_region"))

          # Add short_label to the result
          result$short_label <- i
          predict$short_label <- i

          # Add result to list
          results_list[[i]] <- result 
          predict_list[[i]] <- predict 
          }
    
    # Combine results into a single data frame
    all_results <- do.call(rbind, results_list)
    margins <- do.call(rbind, predict_list)
    
    # Bring in theme
    data2 <- data[, c("short_label", "indicator_order", "theme", "desirable_direction")]
    data2 <- data2 %>% unique()
    margins$short_label <- factor(margins$short_label)
    margins <- left_join(margins, data2, by = c("short_label"))
    # Clean up 
    margins <- margins %>%
      rename(Year = x,
             y_hat = predicted,
             SE = std.error,
             Region = group)
      
    marginsplot <- function(data, label) {
        p <- margins%>% 
          filter(margins$short_label == label) %>%
          ggplot(aes(x = as.factor(Year), y = y_hat, color = Region)) +
          geom_point(size = 1) +
          geom_line(aes(group = Region), size = 1) +
          scale_color_manual(values = region_colors) +
          guides(color = FALSE) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_text(size = 7),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8)) +
          labs(y = "Predicted value (% change)") +
          ggtitle(label) 
      print(p)
    }

  # Order themes
  data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))

# Plot per theme
  n <- 1
  for (i in levels(data$theme)) {
    df <- paste0("df_", n)  
    assign(df, data  %>%
             filter(theme == i) %>%
             mutate(short_label = as.factor(short_label)) %>%
             droplevels()) 
    ordered_indicators <- get(df)$short_label
    ind <- paste0("indicators_", n)  
    assign(ind, as.list(levels(ordered_indicators)))
    n <- n + 1
  }
    
  # Now run for all the indicators per theme
    plots_1 <- lapply(indicators_1, function(x) marginsplot(df_1, x)) 
    plots_2 <- lapply(indicators_2, function(x) marginsplot(df_2, x)) 
    plots_3 <- lapply(indicators_3, function(x) marginsplot(df_3, x)) 
    plots_4 <- lapply(indicators_4, function(x) marginsplot(df_4, x)) 
    plots_5 <- lapply(indicators_5, function(x) marginsplot(df_5, x))
  
# Set up a figure for the legend
    forlegend <- function(data, label) {
        p <- margins%>% 
          filter(margins$short_label == label) %>%
          ggplot(aes(x = as.factor(Year), y = y_hat, color = Region)) +
          geom_point(size = 1) +
          geom_line(aes(group = Region), size = 1) +
          scale_color_manual(values = region_colors) +
          guides(color = guide_legend()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_text("Predicted outcome"),
                axis.text.x = element_blank(),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=7),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank()) +
          ggtitle(label) 
      print(p)
    }
  for_legend <- lapply(indicators_5, function(label) forlegend(df_5, label))
  legend <- get_legend(for_legend[[1]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')
  
  # Add legend and save figure
    png(file.path(figtab_out, "SI Figure 1_Theme1_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 2_Theme2_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 3_Theme3_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 4_Theme4_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 5_Theme5_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()

  # Clean up
    for (i in 1:5) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
    }


# Clean up
    rm(all_results, p1,p2,p3,p4,top,bottom,forlegend, legend, oneyear, dat, data2, for_legend, model, predict, predict_list, result, results_list, margins)

```

$~$

#### SI Figures 6, 9, 13, 16, 19: All data with the global weighted mean by thematic area
Graphs over time - all country level data points
Note: where there are points in 2022-2024 with no global mean, it is because there is no data for the weighting variable available yet for that year.

This code creates one figure per theme.
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
 # Make the global mean into a row to visualize "as a country"
    data <- FSCI_2024 %>%
      filter(!(unit == "categorical")) %>%
      mutate(value = as.numeric(value)) %>%
      select(c(country, country_order, value, indicator, year, unit, variable, short_label, variable_order, theme, domain, desirable_direction, globalmean))

    globalmean <- data %>%
      select(-c(country, country_order, value)) %>%
      mutate(value = globalmean,
             country = "Global weighted mean",
             country_order = 195,
             M49_code = "",
             ISO3 = "") %>%
      unique() 
   globalmean <- globalmean[, c("country", "country_order", "value", "indicator", "year", "unit", "variable", "short_label", "variable_order", "theme", "domain", "desirable_direction", "globalmean")]
   
    data <- data  
    # Bind rows
      data <- rbind(data, globalmean)
    
  # Remove global weighted mean for indicators where there are different countries shown per year
    surveyindicators <- c("All 5 food groups", "Child labor", "Female landholdings", "Minimum dietary diversity, child", 
                          "Minimum dietary diversity, women", "NCD-Protect", "NCD-Risk", "Reduced coping strategies", 
                          "Social protection adequacy", "Social protection coverage", "Soft drink consumption", "Zero fruits or vegetables, adult", "Zero fruits or vegetables, child")
    data <- data %>%
      mutate(value = case_when(short_label %in% surveyindicators & country == "Global weighted mean" ~ NA, 
                               TRUE ~ value))
      
  # Organize
    data <- droplevels(data)
    data <- data %>% arrange(indicator, year, country_order) 
    data$short_label <- as.character(data$short_label)
    data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))
    
  # Plot
    plotdot <- function(data, x) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(country_order, year) %>%
          ggplot(aes(x = year, y = value, group = country)) +
          geom_point(aes(color = country)) + 
          scale_color_manual(values = ifelse(data$country == "Global weighted mean",
                                              "maroon", "lightgray")) +
          guides(color = guide_none()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8),
                plot.subtitle = element_text(size = 7, color = "black")) +
          labs(title = x) 
    }

  # Plot per theme
    n <- 1
      for (i in levels(data$theme)) {
        df <- paste0("df_", n)  
        assign(df, data %>%
                 filter(theme == i) %>%
                 mutate(indicator = as.factor(indicator),
                        year = as.factor(year)) %>%
                 droplevels() %>%
                 arrange(indicator, year, country_order)) 
        ordered_indicators <- fct_reorder(get(df)$short_label, get(df)$variable_order)
        ind <- paste0("indicators_", n)  
        assign(ind, as.list(levels(ordered_indicators)))
        n <- n + 1
        }
      
      plots_1 <- lapply(indicators_1, function(x) plotdot(df_1, x)) 
      plots_2 <- lapply(indicators_2, function(x) plotdot(df_2, x)) 
      plots_3 <- lapply(indicators_3, function(x) plotdot(df_3, x)) 
      plots_4 <- lapply(indicators_4, function(x) plotdot(df_4, x)) 
      plots_5 <- lapply(indicators_5, function(x) plotdot(df_5, x)) 

  # Set up a figure for the legend
  forlegend <- function(data, x) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(country_order, year) %>%
          ggplot(aes(x = year, y = value, group = country)) +
          geom_point(aes(color = country), size = 3) + 
          scale_color_manual(values = ifelse(data$country == "Global weighted mean",
                                              "maroon", "lightgray"),
                             labels = c("Country data point", "Global weighted mean")) +
          guides(color = guide_legend()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_blank(),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=9),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank())
    }
                
  df_2_leg <- df_2 %>% filter(country == "Italy" | country == "Global weighted mean")
  for_legend <- lapply(indicators_2, function(x) forlegend(df_2_leg, x))
  legend <- get_legend(for_legend[[7]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')
  
  # Add legend and save figure
    png(file.path(figtab_out, "SI Figure 6_Theme1 all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 9_Theme2  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 13_Theme3  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 16_Theme4  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 19_Theme5  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()

  # Clean up
    rm(ordered_indicators, indicators, forpaper, data, data2, plots, df_2_leg, legend, for_legend, globalmean, globalmeans)
    for (i in 1:5) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
      if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }

    }

```


#### SI Figures 7,10, 14, 17, 20: Data points by region
This code creates one figure per theme.
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Set up the data with only aggregate values
    surveyindicators <- c("All 5 food groups", "Child labor", "Female landholdings", "Minimum dietary diversity, child", 
                              "Minimum dietary diversity, women", "NCD-Protect", "NCD-Risk", "Reduced coping strategies", 
                              "Social protection adequacy", "Social protection coverage", "Soft drink consumption", "Zero fruits or vegetables, adult", "Zero fruits or vegetables, child")

  data <- FSCI_2024 %>%
    filter(!(unit == "categorical")) %>%
    filter(!(is.na(indicator_order))) %>%
    # Eliminate survey indicators
    filter(!(short_label %in% surveyindicators)) %>%
    select(c(desirable_direction, year, short_label, indicator_order, regionmean, FSCI_region, incomegrpmean, income_group, globalmean, theme)) %>% unique() %>%
    arrange(indicator_order, year) %>%
    mutate(year = as.factor(year)) %>%
    rename('Global mean' = globalmean)
  data <- droplevels(data)
  data$short_label <- factor(data$short_label)
  data <- data %>% droplevels()
  
  # Order themes
  data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))

# Regional means data
    regions <- data %>%
      select(-c("income_group", "incomegrpmean")) %>%
      unique() %>%
      filter(!(is.na(FSCI_region))) %>%
      pivot_wider(names_from = FSCI_region, values_from = regionmean) %>%
      arrange(indicator_order) %>%
      relocate('Global mean', .after = 'Central Asia') %>%
      pivot_longer(6:15, names_to = "group", values_to = "value")
    regions <- droplevels(regions)
    regions$group <- factor(regions$group)

# Plot function
    plotlines <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = FALSE) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8)) +
          ggtitle(x) 
      print(p)
    }
    
# Run for all indicators   
  ordered_indicators <- fct_reorder(data$short_label, data$indicator_order)
  indicators <- as.list(levels(ordered_indicators))
  lapply(indicators, function(x) plotlines(regions, x, region_colors))  

# Plot per theme - income
  n <- 1
  for (i in levels(data$theme)) {
    df <- paste0("df_", n)  
    assign(df, regions %>%
             filter(theme == i) %>%
             mutate(short_label = as.factor(short_label),
                    year = as.factor(year)) %>%
             droplevels() %>%
             arrange(short_label, year, group)) 
    ordered_indicators <- fct_reorder(get(df)$short_label, get(df)$indicator_order)
    ind <- paste0("indicators_", n)  
    assign(ind, as.list(levels(ordered_indicators)))
    n <- n + 1
  }
    
  # Now run for all the indicators per theme
    plots_1 <- lapply(indicators_1, function(x) plotlines(df_1, x, region_colors)) 
    plots_2 <- lapply(indicators_2, function(x) plotlines(df_2, x, region_colors)) 
    plots_3 <- lapply(indicators_3, function(x) plotlines(df_3, x, region_colors)) 
    plots_4 <- lapply(indicators_4, function(x) plotlines(df_4, x, region_colors)) 
    plots_5 <- lapply(indicators_5, function(x) plotlines(df_5, x, region_colors))
  
# Set up a figure for the legend
  forlegend <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = guide_legend(nrow=2)) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=8),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank()) +
          ggtitle(x) 
      print(p)
  }
  for_legend <- lapply(indicators_5, function(x) forlegend(df_5, x, region_colors))
  legend <- get_legend(for_legend[[1]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')

  png(file.path(figtab_out, "SI Figure 7_Theme1_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
  png(file.path(figtab_out, "SI Figure 10_Theme2_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
    png(file.path(figtab_out, "SI Figure 14_Theme3_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
    png(file.path(figtab_out, "SI Figure 17_Theme4_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
    png(file.path(figtab_out, "SI Figure 20_Theme5_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()

  # Clean up
    rm(up, down, ordered_indicators, indicators, forpaper, data, data2, plots, for_legend, legend, regions)
    for (i in 1:9) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
       if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
     if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }
      
    }

```


#### SI Figures 8, 11, 15, 18, 21: Data points by income group
This code creates one figure per theme.
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Set up the data with only aggregate values
    surveyindicators <- c("All 5 food groups", "Child labor", "Female landholdings", "Minimum dietary diversity, child", 
                              "Minimum dietary diversity, women", "NCD-Protect", "NCD-Risk", "Reduced coping strategies", 
                              "Social protection adequacy", "Social protection coverage", "Soft drink consumption", "Zero fruits or vegetables, adult", "Zero fruits or vegetables, child")

  data <- FSCI_2024 %>%
    filter(!(unit == "categorical")) %>%
    filter(!(is.na(indicator_order))) %>%
    # Eliminate survey indicators
    filter(!(short_label %in% surveyindicators)) %>%
    select(c(desirable_direction, year, short_label, indicator_order, regionmean, FSCI_region, incomegrpmean, income_group, globalmean, theme)) %>% unique() %>%
    arrange(indicator_order, year) %>%
    mutate(year = as.factor(year)) %>%
    rename('Global mean' = globalmean)
  data <- droplevels(data)
  data$short_label <- factor(data$short_label)
  data <- data %>% droplevels()
  
  # Order themes
  data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))

# Income group and metadata table
    incomegroups <- data %>%
      select(-c("FSCI_region", "regionmean")) %>%
      unique() %>%
      filter(!(is.na(income_group))) %>%
      pivot_wider(names_from = income_group, values_from = incomegrpmean) %>%
      arrange(indicator_order) %>%
      relocate('Global mean', .after = 'High income') %>%
      relocate('Upper middle income', .after = 'Lower middle income') %>%
      pivot_longer(6:10, names_to = "group", values_to = "value")
    incomegroups <- droplevels(incomegroups)

# Plot function
    plotlines <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = FALSE) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8)) +
          ggtitle(x) 
      print(p)
    }

# Run for all indicators    
  ordered_indicators <- fct_reorder(data$short_label, data$indicator_order)
  indicators <- as.list(levels(ordered_indicators))
  lapply(indicators, function(x) plotlines(incomegroups, x, income_colors))
    
# Plot per theme - income
  n <- 1
  for (i in levels(data$theme)) {
    df <- paste0("df_", n)  
    assign(df, incomegroups %>%
             filter(theme == i) %>%
             mutate(short_label = as.factor(short_label),
                    year = as.factor(year)) %>%
             droplevels() %>%
             arrange(short_label, year, group)) 
    ordered_indicators <- fct_reorder(get(df)$short_label, get(df)$indicator_order)
    ind <- paste0("indicators_", n)  
    assign(ind, as.list(levels(ordered_indicators)))
    n <- n + 1
  }
    
  # Now run for all the indicators per theme
    plots_1 <- lapply(indicators_1, function(x) plotlines(df_1, x, income_colors)) 
    plots_2 <- lapply(indicators_2, function(x) plotlines(df_2, x, income_colors)) 
    plots_3 <- lapply(indicators_3, function(x) plotlines(df_3, x, income_colors)) 
    plots_4 <- lapply(indicators_4, function(x) plotlines(df_4, x, income_colors)) 
    plots_5 <- lapply(indicators_5, function(x) plotlines(df_5, x, income_colors))
  
# Set up a figure for the legend
  forlegend <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = guide_legend()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=8),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank()) +
          ggtitle(x) 
      print(p)
  }
  for_legend <- lapply(indicators_5, function(x) forlegend(df_5, x, income_colors))
  legend <- get_legend(for_legend[[1]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')
  
  # Add legend and save figure
    png(file.path(figtab_out, "SI Figure 8_Theme1_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 11_Theme2_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 15_Theme3_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 18_Theme4_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure 21_Theme5_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()

  # Clean up
    rm(incomegroups, data, for_legend, indicators, legend)
    for (i in 1:5) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
     if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
    }

```


#### SI Figure 12. Bar chart of total food system emissions
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
  # Filter data to visualize
    data <- FSCI_2024 %>% 
      dplyr::filter(indicator == "Agri-food systems greenhouse gas emissions") %>%
      dplyr::filter(!(is.na(value))) %>%
      dplyr::mutate(value = as.numeric(value)) %>%
      dplyr::group_by(FSCI_region, year) %>%
      dplyr::summarize(region_total = sum(value))
    
  png(file.path(figtab_out, "SI Figure 12_TotalEmissions.png"), width = 8.5, height = 8.5, 
      unit = "in", res = 300)
    ggplot(data, aes(x = year, y = region_total, fill = FSCI_region)) +
      geom_bar(position="stack", stat="identity") + 
      scale_fill_manual(values = region_colors) +
      guides(fill = guide_legend(title = "")) +
      theme_classic() +
      labs(y = "kt CO2eq (AR5)",
           x = "") 
  dev.off()
  
# Clean up
  rm(data)

```
$~$

#### SI Figure 22
```{r, warning = FALSE, messages = FALSE, echo = TRUE}
# Set up the data
    data <- Interactions_ExpertElicit_Bidirect %>%
      mutate(relationship = case_when(from == to ~ 3,
                TRUE ~ relationship))

# Plot
  plot <- data %>% 
    # Create an ordering variable so X-axis is grouped by theme
    group_by(from) %>%
    mutate(var_order = seq_along(from)) %>%
    ungroup() %>%
    # Create an ordering variable for theme
    mutate(theme_order = case_when(from_theme == "Diets, Nutrition, & Health" ~ 1,
                                   from_theme == "Environment, Natural resources, & Production" ~ 2,
                                   from_theme == "Livelihoods, Poverty, & Equity" ~ 3,
                                   from_theme == "Governance" ~ 4,
                                   from_theme == "Resilience" ~ 5)) %>%

    ggplot(aes(y = fct_reorder(from, from_order), x = fct_reorder(to, var_order), fill = as.factor(relationship))) +
      geom_tile() +
      facet_col(vars(fct_reorder(from_theme,theme_order)), scales = "free_y", space = "free") +
      scale_y_discrete(limits = rev) +
      scale_x_discrete(position = "top") +
      scale_fill_manual(values = c("white",  "#244369", "#DB5079","gray35"),
                        breaks = c(0,1,2)) +
      theme_classic() +
      theme(legend.position = "none",
            axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            axis.text.x = element_text(angle = 90, size = 7),
            axis.text.x.top = element_text(vjust = 0.05, hjust = 0),
            axis.text.y = element_text(size = 7)) +
    geom_vline(xintercept = seq(1.5, length(unique(data$to)) - 0.5, 1), 
             linetype = "solid", 
             color = "gray50", 
             size = 0.25) +
    geom_hline(yintercept = seq(1.5, length(unique(data$from)) - 0.5, 1), 
               linetype = "solid", 
               color = "gray50", 
               size = 0.25) 

png(file.path(figtab_out, "SI Figure 22_Bidirectional relationships.png"), width = 7.5, height = 10, unit = "in", res = 300)
  plot  
dev.off()


# Number of bidirectional
      data <- data %>% unique()
      bidirect_total <- data %>%
                  filter(relationship == 2) %>%
                  summarise(count = n())
      bidirect_difftheme <- data %>%
                  filter(relationship == 2) %>%
                  filter(from_theme != to_theme) %>%
                  summarise(count = n())
      
```



#### SI Figures 23
Circular diagram of direct relationships
```{r, warning = FALSE, messages = FALSE, echo = TRUE}
# Circular diagram
# Use the long format and simplify column names
  df_from <- Interactions_ExpertElicit_AdjacencyMatrix %>% select(c("from", "from_theme")) %>% unique()
  connect <- Interactions_ExpertElicit_Direct %>% 
    rename(value = relationship) %>%
    select(-c(from_theme)) %>%
    filter(value !=0) # Keep only the connections (the edges in graph theory language)

# Number of connections per indicator
  connections <- c(as.character(connect$from), as.character(connect$to)) %>%
    as.tibble() %>%
    group_by(value) %>%
    summarize(n=n()) 
  colnames(connections) <- c("indicator", "n")

# Create a table with the number of connections per indicator
  connect_tbl <- connections %>%
    arrange(desc(n))
  colnames(connect_tbl) <- c("Indicator", "N connections")

# Reorder data set and make the graph
  connections <- left_join(connections, df_from, by = c("indicator"  = "from")) %>%
    select(c(1:2, "from_theme")) %>%
    rename(group = from_theme,
           name = indicator) %>%
    arrange(group) %>%
    mutate(name = as.factor(name)) %>% unique()

# keep only indicators in edges
  connect <- connect %>%
    filter(from %in% connections$name) %>%
    filter(to %in% connections$name) 

# Add label angle
  number_of_bar=nrow(connections)
  connections$id = seq(1, nrow(connections))
  angle = 360 * (connections$id-0.5) /number_of_bar # Subtract 0.5 for letter positioning so that the angle of the label is at the center of the bars. Not extreme right (1) or extreme left (0)    
  connections$hjust <- ifelse(angle > 90 & angle<270, 1, 0)
  connections$angle <- ifelse(angle > 90 & angle<270, angle+180, angle)

# Create a graph object with igraph
  graph <- igraph::graph_from_data_frame(connect, vertices = connections, directed = TRUE)

# Make the graph
png(file.path(figtab_out, "SI Figure 23.png"), width = 10, height = 7.5, unit = "in", res = 300)

ggraph::ggraph(graph, layout="circle") + 
  ggraph::geom_edge_link(alpha=0.2, width=0.3) +
  ggraph::geom_node_point(aes(size=n, color=as.factor(group), fill=group), alpha=0.9) +
  scale_size_continuous(range=c(0.5,8)) +
  scale_color_manual(values = themes_colors) +
  ggraph::geom_node_text(aes(label=paste("    ",name,"    "), 
                     angle=angle, hjust=hjust), size=2.3, color="black") +
  theme_void() +
  guides(color = guide_legend(order = 1,
                              title = "Theme",
                              override.aes = list(size = 5)),
         size = guide_legend(order = 1, title = "Number of direct connections \n(from and to, combined)"),
         fill = FALSE) +
  theme(legend.position="right",
    plot.margin=unit(c(0,0,0,0), "null"),
    panel.spacing=unit(c(0,0,0,0), "null"),
    plot.caption.position = "plot") +
  expand_limits(x = c(-1.5, 1.5), y = c(-1.7, 1.5)) 

dev.off()

# Clean up
  rm(connect, connect_tbl, connections, graph)

```

$~$

#### SI Figure 24: Network diagram
```{r, warning = FALSE, messages = FALSE, echo = TRUE}
# Create an igraph object from the matrix of first order connections
  network <- igraph::graph_from_adjacency_matrix(Interactions_ExpertElicit_DirectMatrix)

# Convert to a data frame to merge in attributes
  network_df <- igraph::as_data_frame(network, 'both')

# Add the theme as an attribute to the vertices
  network_df$vertices <- network_df$vertices %>% 
    left_join(df_from, c('name' = 'from'))

# Turn back into an igraph object
  network2 <- graph_from_data_frame(network_df$edges,
                        directed = TRUE,
                        vertices = network_df$vertices)

# plot it
  png(file.path(figtab_out, "SI Figure 24.png"), width = 8.5, height = 8.5, unit = "in", res = 300)
  igraph::plot.igraph(network2, edge.arrow.size = 0.2, layout = layout_with_fr,
       vertex.size = 10, 
       vertex.color = themes_colors[as.numeric(as.factor(vertex_attr(network2, "from_theme")))], 
       vertex.label.dist	= 0, 
       vertex.label.cex	= .5,
       vertex.label.color = "black") 
  legend("topleft", 
         cex = .8,
         bty = "n",
         legend = levels(df_from$from_theme),
         fill = themes_colors, 
         border=NA)
  dev.off()
  
  igraph::plot.igraph(network2, edge.arrow.size = 0.2, layout = layout_with_fr,
       vertex.size = 10, 
       vertex.color = themes_colors[as.numeric(as.factor(vertex_attr(network2, "from_theme")))], 
       vertex.label.dist	= 0, 
       vertex.label.cex	= .5,
       vertex.label.color = "black") 
  legend("topleft", 
         cex = .5,
         bty = "n",
         legend = levels(df_from$from_theme),
         fill = themes_colors, 
         border=NA)
dev.off()

# Clean up
  rm(network, network_df, network2, df_from)

```


#### Supplementary Data 1: Metadata and Codebook Latest data point per indicator
This code creates the table that lists the latest data point per country-indicator pair
```{r, warning = FALSE, messages = FALSE, echo = TRUE}
latestdata <- FSCI_2024 %>%
  filter(!(is.na(value))) %>%
  group_by(country, indicator) %>%
  mutate(maxyear = max(year)) %>%
  ungroup() %>%
  filter(year == maxyear) %>%
  sort_by(country ~ indicator_order) %>%
  select(c(country, year, indicator)) %>%
  pivot_wider(names_from = indicator, values_from = year) %>%
  mutate(across(everything(), ~case_when(. == "NULL" ~ "", TRUE ~ as.character(.)))) %>%
  mutate(across(2:60, ~as.numeric(.))) %>%
  arrange(country)
write.csv(latestdata, file = file.path(figtab_out, "Latest data point.csv"))

```